> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 메모리 종류

컴퓨터에는 여러 종류의 메모리가 있다. 이번 포스트에서 왜 컴퓨터에 여러 종류의 메모리가 필요한지 서로 무엇이 다른지 알아보자.

위의 그림은 컴퓨터에서 사용되는 메모리들이다. 아래로 갈수록 가격은 싸지고 용량은 커지지만 속도는 느려진다. 먼저 레지스터부터 알아보자. 레지스터는 가장 빠른 기억장소로 CPU내에 존재한다. 컴퓨터의 전원이 꺼지면 데이터가 사라지기 때문에 휘발성 메모리라고 부른다. CPU를 구분할 때 32bit, 64bit를 많이 들어봤을 것이다. 여기서 32bit와 64bit는 레지스터의 크기를 말한다. 32bit 레지스터를 가지고 있으면 32bit CPU라고 말하고 반대로 64bit 레지스터를 가지고 있으면 64bit CPU라고 말한다. CPU는 계산할 때 메인 메모리에 있는 값을 레지스터로 가져와 계산한다. 계산 결과는 다시 메인 메모리에 저장시킨다. 예시를 보자.

```
movl $5, -4(%rbp)
movl $7, -8(%rbp)
movl -4(%rbp), %edx
movl -8(%rbp), %eax
addl %edx, %eax
movl %eax, -12(%rbp)
nop
addq $48, %rsp
popq %rbp
ret
```

위의 코드는 이전 포스트에서 컴파일을 할 때 생성된 어셈블리 코드 일부이다. 어셈블리 코드를 보는 이유는 기계어로 1:1 매칭이 되기 때문에 실제로 레지스터를 사용하는 것을 볼 수 있기 때문이다. 여기서 왼쪽에 있는 것은 명령어이고 오른쪽은 데이터를 의미한다. 정확히 무슨 일을 하는지 알 수 없지만 이렇게 레지스터를 가지고 무언가를 처리한다. 그럼 레지스터가 무엇인지 알아보았으니 우리 프로그램이 실제로 올라갈 메인 메모리를 살펴보자. 레지스터와 메인 메모리 사이에 캐시라는 휘발성 메모리가 있다. 먼저 캐시부터 살펴보자. 레지스터는 CPU가 사용하는 메모리로 굉장히 빠르다. 그에 비해 메인 메모리는 너무 느리다. 메인 메모리에 있는 값을 레지스터로 옮기려면 한참 걸리기 때문에 필요할 것 같은 데이터를 미리 가져오기로 한다. 미리 가져완 데이터를 저장하는 곳이 캐시이다. 캐시는 성능의 이유로 여러 개 둔다. 만약 CPU가 값을 요청하여 레지스터로 값을 옮겨야 한다면 단계에 따라 가장 속도가 바른 L1 캐시를 확인하고 없다면 L2 캐시를 확인하고 없다면 L3 캐시를 확인하는데 여기도 없을 때 메인 메모리로 값을 가져온다. 이제 제일 중요한 메인 메모리에 대해 살펴보자. 메인 메모리는 실제 운영체제와 다른 프로세스들이 올라가는 공간이다. 전원이 공급되지 않으면 데이터가 지워지기 때문에 휘발성 메모리다. HDD나 SSD보다 속도는 빠르지만 가격이 비싸기 때문에 데이터를 저장하기보다는 실행 중인 프로그램만 올린다. 이제 보조저장장치인 SSD와 HDD에 대해 알아보자. 컴퓨터는 사무용 프로그램, 게임, 작업한 파일을 저장할 필요가 있다. 이전에 살펴본 메모리들은 휘발성 메모리고 가격이 비싸서 저장하기 어려웠다. 그래서 가격이 저렴하고 전원이 공급되지 않아도 데이터가 지워지지 않는 비휘발성 메모리를 만들었다. 요즘 HDD 가격을 보면 테라 단위가 몇만 원밖에 안 한다. HDD의 용량을 메인 메모리로 확보하려면 엄청난 비용이 들 것이다. 메인 메모리가 이렇게 비싼데 캐시와 레지스터를 1TB를 만들려면 일반인들은 컴퓨터를 사용할 수 없을 것이다. 현재 우리는 레지스터와 캐시, 메인 메모리, HDD를 이용하여 가격과 속도를 절충해주는 구조 덕분에 저렴하고 빠른 컴퓨터를 사용할 수 있다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 메모리와 주소

이제 메모리들 중에서 가장 중요한 메인 메모리를 알아보자. 이 글에서 편의상 메인 메모리를 메모리라고 부르겠다. 오늘날 컴퓨터는 폰 노이만 구조로 되어있고 폰 노이만 구조는 모든 프로그램을 메모리에 올려 실행시킨다. 유니 프로그래밍 환경에서 하나의 프로그램만 메모리에 올라갔기 때문에 메모리 관리가 어렵지 않았으나 멀티프로그래밍 환경에서는 여러 프로세스가 올라오니 복잡하고 어려워졌다. 운영체제는 메모리를 관리하기 위해 1byte 크기로 구역을 나누고 숫자를 매긴다. 이 숫자를 주소라고 부른다.

### 32bit CPU와 64bit CPU

32bit CPU는 레지스터 크기가 32bit이고 CPU가 처리하는 ALU도 데이터가 이동하는 버스도 전부 32bit이다. 또한 CPU가 다룰 수 있는 메모리 크기도 2^32로 4GB이다. 64bit CPU는 레지스터 크기와 ALU, 버스의 크기도 64bit이다. 다룰 수 있는 메모리 크기도 2^64로 16EB에 가까운데 실제로는 운영체제 종류마다 정해져 있다. 64bit CPU가 32bit CPU보다 한 번에 처리할 수 있는 양이 많기 때문에 속도가 더 빠르다.

### 물리주소와 논리주소

메모리를 컴퓨터에 연결하면 0x0번지부터 시작하는 주소공간이 있는데 이를 물리주소 공간이라고 한다. 이와 다르게 사용자 관점에서 바라본 주소공간은 논리주소 공간이라고 부른다. 사용자는 물리주소를 몰라도 논리주소로 물리주소에 접근할 수 있다. 메모리에는 운영체제와 수 많은 프로세스가 올라간다. 그중에 운영체제는 특별하기 때문에 운영체제를 위한 공간을 따로 마련해 둔다. 만약에 사용자가 악의적인 프로그램을 만들어 사용자 프로세스가 운영체제를 침범 하면 굉장히 위험해질 수 있다. 그래서 하드웨어적으로 운영체제 공간과 사용자 공간을 나누는 경계 레지스터를 만들었다. 경계 레지스터는 CPU 내에 존재하는 레지스터로 메모리 관리자가 사용자 프로세스가 경계 레지스터의 값을 벗어나는지 검사하고 만약 벗어났다면 그 프로세스를 종료시킨다.

### 절대주소와 상대주소

메모리에는 절대주소와 상대주소라는 개념이 있다. 개발자는 프로그램을 만들 때 프로그램이 실행 될 주소를 신경 쓰지 않고 개발한다. 이는 컴파일러가 컴파일을 할 때 메모리 0번지에서 실행한다고 가정하기 때문이다. 개발자의 프로그램을 실행시켜 메모리의 사용자 공간 0x4000번지에 올라왔다고 가정해 보자. 컴파일러는 0x0번지라고 가정해서 프로그램을 만들었고 이는 상대주소이다. 실제 프로그램이 올라간 주소는 0x4000번지인데 이는 메모리 관리자가 바라본 절대주소이다. 사용자가 바라본 주소인 상대주소는 논리주소 공간이라고 부르고 메모리 관리자가 바라본 주소인 절대주소는 물리주소 공간이라고 부른다. 예를 들어 사용자가 0x100번지(상대주소, 논리주소)에 있는 데이터를 요청했다고 하자. CPU는 메모리 관리자에게 0x100번지에 있는 데이터를 요청한다. 메모리 관리자는 CPU가 요청한 0x100번지와 재배치 레지스터에 있는 0x4000번지 값을 더한 0x4100(절대주소, 물리주소)에 접근해서 데이터를 가져온다.

> 재배치 레지스터에는 프로그램읭 시작주소를 저장한다.

메모리 관리자는 사용자가 메모리에 접근할 때마다 이렇게 계산한다. 메모리 관리자 덕분에 모든 사용자 프로세스는 0x0번지부터 시작한다는 가정으로 편하게 프로그램을 만들 수 있고 만약 시작영역이 바뀌더라도 재배치 레지스터만 변경해 주면 되기 때문에 굉장히 유연하다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 메모리 할당방식

예전 유니프로그래밍 환경에서 메모리보다 큰 프로그램을 실행시키는 방법은 무엇이 있을까? 방법은 간단하다. 큰 프로그램을 메모리에 올릴 수 있도록 잘라서 당장 실행시켜야 할 부분만 메모리에 올리고 나머지는 용량이 큰 HDD에 저장하는 기법이다. 이 기법을 메모리 오버레이라고 한다. 큰 프로그램을 작게 나누어 일부만 실행하고 일부는 하드디스크에 저장된다고 하였는데 정확히는 하드디스크의 스왑영역이라는 곳에 저장된다. 만약 메모리에 1GB를 올리고 스왑영역에 8GB 올려 실행한다고 하면 사용자는 메모리가 9GB인 것처럼 느껴질 것이다.

> 스왑: 스왑영역에 있는 데이터 일부를 메모리로 가져오고 메모리에 있는 데이터를 스왑영역으로 옯기는 것

하지만 스왑과정이 있기 때문에 실제 메모리가 9GB인 컴퓨터보다는 느리게 동작한다. 그럼 오늘날과 같이 메모리에 여러 개의 프로세스가 올라가는 멀티프로그래밍 환경에서는 메모리를 어떻게 관리할까? 운영체제를 연구하는 사람들은 메모리를 어떤 크기로 나눌까 고민을 하였고 2가지 방식을 찾았다. 첫 번째 방식은 가변분할방식이다. 가변분할방식은 프로세스의 크기에 따라 메모리를 나누는 방식이다. 두 번째 방식은 고정분할방식으로 프로세스의 크기와는 상관없이 메모리를 정해진 크기로 나누는 방식이다.

가변분할방식과 고정분할방식을 예시로 보자. 크기가 5MB인 프로세스A가 있고 2MB인 프로세스 B와 1MB인 프로세스 C가 있다고 하자. 가변분할방식은 프로세스의 크기에 따라 메모리를 나누기 때문에 메모리에 프로세스 A를 위한 5MB를 확보하고 프로세스 B를 위한 2MB를 확보하고 프로세스 C를 위한 1MB를 확보한다. 한 프로세스가 메모리에 연속된 공간에 할당되기 때문에 연속메모리할당이라고 한다. 고정분할방식은 프로세스의 크기에 상관없이 메모리를 정해진 크기로 나눈다. 이 예시에서는 메모리 크기를 2MB로 나눈다고 가정하자. 그럼 5MB가 필요한 프로세스 A는 2MB로 나눈 구역 3개에 나눠서 할당된다. 3번째 구역 1MB는 일단 2MB로 할당하고 빈 공간 1MB가 남는다. 프로세스 B는 2MB로 크기가 정확히 맞기에 그대로 할당한다. 프로세스 C는 1MB이지만 메모리에 2MB를 할당하고 1MB는 빈 공간으로 둔다. 이 방식은 한 프로세스가 메모리에 분산되어 할당되기 때문에 비연속메모리할당이라고 한다.

그럼 가변분할방식과 고정분할방식의 장단점에 대해 알아보자. 가변분할방식의 장점은 메모리에 연속된 공간에 할당되기 때문에 더 크게 할당되어서 낭비되는 공간인 내부단편화가 없다. 단점으로는 외부단편화가 발생하는데 외부단편화에 대해서는 조금 뒤에 살펴보자. 고정분할방식의 장점은 구현이 간단하고 오버헤드가 적다라는 것이다. 단점으로는 작은 프로세스도 큰 영역에 할당되어 공간이 낭비되는 내부단편화가 발생한다는 것이다. 오늘날 운영체제는 가변분할방식과 고정분할방식을 혼합하여 단점을 줄여가고 있다.

가변분할방식에서 발생하는 외부단편화 문제를 알아보자. 다음 포스트부터 작성할 가상메모리 시스템에서 가변분할방식을 세그멘테이션이라 부른다. 메모리에 서로 다른 크기를 가지고 있는 여러개의 프로세스가 올라왔다 가정하자. (p1: 50MB, p2: 30MB, p3: 15MB, p4: 10MB) 처음 상황에는 문제가 없다. 하지만 p1과 p4가 작업을 마치고 메모리에 내려간다. 여기서 메모리에 p1과 p4가 있던 공간에 빈 공간이 생긴다. p1에 있던 공간은 50MB, p4에 있던 공간은 10MB이다. 여기서 크기가 60MB인 프로세스가 메모리를 원한다. p1과 p4의 공간을 합치면 60MB이니 할당할 수 있을 것 같지만 연속된 공간이 아니기 대문에 새로운 프로세스에게 메모리 할당을 해줄 수 없다. 이것을 외부단편화라고 한다. 이러한 상황이 왔을 때 어떻게 해결할까? 외부단편화가 발생한 공간을 합쳐주는 조각모음을 해주면 된다. 하지만 조각모음을 하려면 현재 메모리에 실행되고 있는 프로세스들의 작업을 일시중지해야 하고 메모리 공간을 이동시키는 작업을 해야 하기 때문에 오버헤드가 발생한다.

이제 공정분할방식에 발생하는 내부단편화 문제를 살펴보자. 가상메모리 시스템에서 고정분할방식을 페이징이라고 한다. 책의 페이지처럼 크기가 정해져 있다고 해서 붙은 이름이다. 메모리에 서로 다른 크기를 가지고 있는 여러 프로세스가 올라왔다고 가정하자. p1: 50MB, p2: 30MB, p3: 15MB, p4: 10MB) 예시에서는 20MB 크기로 메모리를 분할한다고 가정하자. 각각의 프로세스들이 필요한 공간만큼 20MB로 쪼개져 할당된다. p1은 메모리가 부족하기 때문에 10MB는 하드디스크 스왑영역에 할당된다. 또한 p3, p4는 할당된 20MB보다 크기가 작기 때문에 빈 공간이 생겨서 낭비가 발생한다. 이를 내부단편화라고 부르는데 이를 해결하는 방법은 없고 분할된 크기를 조절해서 내부단편화를 최소화하는 방법밖에 없다.

그럼 가변분할방식과 고정분할방식을 혼합해 단점을 최소화한 버디 시스템에 대해서 알아보자. 버디 시스템은 2의 제곱수로 메모리를 분할해 메모리를 할당하는 방식이다. 계산의 편의성을 위해 작은 값으로 예시를 들어보자. 메모리 크기가 2^11로 2048byte라고 가정하자. 크기가 500byte인 프로세스가 메모리 할당을 원한다. 그럼 먼저 2의 제곱수로 500byte보다 작은 값을 만날때 까지 쪼갠다. 3번을 쪼개면 256byte가 나오는데 여기에는 500byte를 할당할 수 없으니 이보다 큰 구역의 512byte 공간에 프로세스를 할당한다. 여기서도 내부단편화가 발생하지만 12byte밖에 발생하지 않는다. 이 프로세스가 사용을 마치고 메모리에 나가도 근접한 메모리 공간을 합치기 쉽다. 그 이유는 2의 제곱수로 동일하게 나눠서 반대로 조립만 하면 큰 공간이 만들어지기 때문에 조각모음보다 훨씬 간단하다. 이 방식의 장점은 가변분할방식처럼 프로세스의 크기에 따라 할당되는 메모리 크기가 달라지고 외부단편화를 방지하기 위해 메모리 공간을 확보하는 것 또한 간단하다. 그리고 고정분할방식처럼 내부단편화가 발생하기는 하지만 많은 공간의 낭비가 발생하지 않는다.
