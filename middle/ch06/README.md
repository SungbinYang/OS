> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 메모리 종류

컴퓨터에는 여러 종류의 메모리가 있다. 이번 포스트에서 왜 컴퓨터에 여러 종류의 메모리가 필요한지 서로 무엇이 다른지 알아보자.

위의 그림은 컴퓨터에서 사용되는 메모리들이다. 아래로 갈수록 가격은 싸지고 용량은 커지지만 속도는 느려진다. 먼저 레지스터부터 알아보자. 레지스터는 가장 빠른 기억장소로 CPU내에 존재한다. 컴퓨터의 전원이 꺼지면 데이터가 사라지기 때문에 휘발성 메모리라고 부른다. CPU를 구분할 때 32bit, 64bit를 많이 들어봤을 것이다. 여기서 32bit와 64bit는 레지스터의 크기를 말한다. 32bit 레지스터를 가지고 있으면 32bit CPU라고 말하고 반대로 64bit 레지스터를 가지고 있으면 64bit CPU라고 말한다. CPU는 계산할 때 메인 메모리에 있는 값을 레지스터로 가져와 계산한다. 계산 결과는 다시 메인 메모리에 저장시킨다. 예시를 보자.

```
movl $5, -4(%rbp)
movl $7, -8(%rbp)
movl -4(%rbp), %edx
movl -8(%rbp), %eax
addl %edx, %eax
movl %eax, -12(%rbp)
nop
addq $48, %rsp
popq %rbp
ret
```

위의 코드는 이전 포스트에서 컴파일을 할 때 생성된 어셈블리 코드 일부이다. 어셈블리 코드를 보는 이유는 기계어로 1:1 매칭이 되기 때문에 실제로 레지스터를 사용하는 것을 볼 수 있기 때문이다. 여기서 왼쪽에 있는 것은 명령어이고 오른쪽은 데이터를 의미한다. 정확히 무슨 일을 하는지 알 수 없지만 이렇게 레지스터를 가지고 무언가를 처리한다. 그럼 레지스터가 무엇인지 알아보았으니 우리 프로그램이 실제로 올라갈 메인 메모리를 살펴보자. 레지스터와 메인 메모리 사이에 캐시라는 휘발성 메모리가 있다. 먼저 캐시부터 살펴보자. 레지스터는 CPU가 사용하는 메모리로 굉장히 빠르다. 그에 비해 메인 메모리는 너무 느리다. 메인 메모리에 있는 값을 레지스터로 옮기려면 한참 걸리기 때문에 필요할 것 같은 데이터를 미리 가져오기로 한다. 미리 가져완 데이터를 저장하는 곳이 캐시이다. 캐시는 성능의 이유로 여러 개 둔다. 만약 CPU가 값을 요청하여 레지스터로 값을 옮겨야 한다면 단계에 따라 가장 속도가 바른 L1 캐시를 확인하고 없다면 L2 캐시를 확인하고 없다면 L3 캐시를 확인하는데 여기도 없을 때 메인 메모리로 값을 가져온다. 이제 제일 중요한 메인 메모리에 대해 살펴보자. 메인 메모리는 실제 운영체제와 다른 프로세스들이 올라가는 공간이다. 전원이 공급되지 않으면 데이터가 지워지기 때문에 휘발성 메모리다. HDD나 SSD보다 속도는 빠르지만 가격이 비싸기 때문에 데이터를 저장하기보다는 실행 중인 프로그램만 올린다. 이제 보조저장장치인 SSD와 HDD에 대해 알아보자. 컴퓨터는 사무용 프로그램, 게임, 작업한 파일을 저장할 필요가 있다. 이전에 살펴본 메모리들은 휘발성 메모리고 가격이 비싸서 저장하기 어려웠다. 그래서 가격이 저렴하고 전원이 공급되지 않아도 데이터가 지워지지 않는 비휘발성 메모리를 만들었다. 요즘 HDD 가격을 보면 테라 단위가 몇만 원밖에 안 한다. HDD의 용량을 메인 메모리로 확보하려면 엄청난 비용이 들 것이다. 메인 메모리가 이렇게 비싼데 캐시와 레지스터를 1TB를 만들려면 일반인들은 컴퓨터를 사용할 수 없을 것이다. 현재 우리는 레지스터와 캐시, 메인 메모리, HDD를 이용하여 가격과 속도를 절충해주는 구조 덕분에 저렴하고 빠른 컴퓨터를 사용할 수 있다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 메모리와 주소

이제 메모리들 중에서 가장 중요한 메인 메모리를 알아보자. 이 글에서 편의상 메인 메모리를 메모리라고 부르겠다. 오늘날 컴퓨터는 폰 노이만 구조로 되어있고 폰 노이만 구조는 모든 프로그램을 메모리에 올려 실행시킨다. 유니 프로그래밍 환경에서 하나의 프로그램만 메모리에 올라갔기 때문에 메모리 관리가 어렵지 않았으나 멀티프로그래밍 환경에서는 여러 프로세스가 올라오니 복잡하고 어려워졌다. 운영체제는 메모리를 관리하기 위해 1byte 크기로 구역을 나누고 숫자를 매긴다. 이 숫자를 주소라고 부른다.

### 32bit CPU와 64bit CPU

32bit CPU는 레지스터 크기가 32bit이고 CPU가 처리하는 ALU도 데이터가 이동하는 버스도 전부 32bit이다. 또한 CPU가 다룰 수 있는 메모리 크기도 2^32로 4GB이다. 64bit CPU는 레지스터 크기와 ALU, 버스의 크기도 64bit이다. 다룰 수 있는 메모리 크기도 2^64로 16EB에 가까운데 실제로는 운영체제 종류마다 정해져 있다. 64bit CPU가 32bit CPU보다 한 번에 처리할 수 있는 양이 많기 때문에 속도가 더 빠르다.

### 물리주소와 논리주소

메모리를 컴퓨터에 연결하면 0x0번지부터 시작하는 주소공간이 있는데 이를 물리주소 공간이라고 한다. 이와 다르게 사용자 관점에서 바라본 주소공간은 논리주소 공간이라고 부른다. 사용자는 물리주소를 몰라도 논리주소로 물리주소에 접근할 수 있다. 메모리에는 운영체제와 수 많은 프로세스가 올라간다. 그중에 운영체제는 특별하기 때문에 운영체제를 위한 공간을 따로 마련해 둔다. 만약에 사용자가 악의적인 프로그램을 만들어 사용자 프로세스가 운영체제를 침범 하면 굉장히 위험해질 수 있다. 그래서 하드웨어적으로 운영체제 공간과 사용자 공간을 나누는 경계 레지스터를 만들었다. 경계 레지스터는 CPU 내에 존재하는 레지스터로 메모리 관리자가 사용자 프로세스가 경계 레지스터의 값을 벗어나는지 검사하고 만약 벗어났다면 그 프로세스를 종료시킨다.

### 절대주소와 상대주소

메모리에는 절대주소와 상대주소라는 개념이 있다. 개발자는 프로그램을 만들 때 프로그램이 실행 될 주소를 신경 쓰지 않고 개발한다. 이는 컴파일러가 컴파일을 할 때 메모리 0번지에서 실행한다고 가정하기 때문이다. 개발자의 프로그램을 실행시켜 메모리의 사용자 공간 0x4000번지에 올라왔다고 가정해 보자. 컴파일러는 0x0번지라고 가정해서 프로그램을 만들었고 이는 상대주소이다. 실제 프로그램이 올라간 주소는 0x4000번지인데 이는 메모리 관리자가 바라본 절대주소이다. 사용자가 바라본 주소인 상대주소는 논리주소 공간이라고 부르고 메모리 관리자가 바라본 주소인 절대주소는 물리주소 공간이라고 부른다. 예를 들어 사용자가 0x100번지(상대주소, 논리주소)에 있는 데이터를 요청했다고 하자. CPU는 메모리 관리자에게 0x100번지에 있는 데이터를 요청한다. 메모리 관리자는 CPU가 요청한 0x100번지와 재배치 레지스터에 있는 0x4000번지 값을 더한 0x4100(절대주소, 물리주소)에 접근해서 데이터를 가져온다.

> 재배치 레지스터에는 프로그램읭 시작주소를 저장한다.

메모리 관리자는 사용자가 메모리에 접근할 때마다 이렇게 계산한다. 메모리 관리자 덕분에 모든 사용자 프로세스는 0x0번지부터 시작한다는 가정으로 편하게 프로그램을 만들 수 있고 만약 시작영역이 바뀌더라도 재배치 레지스터만 변경해 주면 되기 때문에 굉장히 유연하다.
