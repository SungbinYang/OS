> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 교착상태(데드락)

여러 프로세스가 서로 다른 프로세스의 작업이 끝나기를 기다리다가 아무도 작업을 진행하지 못하는 상태를 교착상태라고 한다. 교착상태는 일상생활에서도 발생할 수 있다. 복잡한 도시의 퇴근길을 생각해 보자. 어떤 차량이 꼬리물기를 해서 도로가 마비되었다고 하자. 앞에서 길을 터줘야 갈 수 있는데 지금은 이러지도 저러지도 못하는 상황이다. 이럴 때 누군가 도로를 통제해서 해결해줘야 한다. 교착상태가 발생하는 이유는 공유자원 때문이다. 만약 어떤 자원을 여러 개의 프로세스가 공유하지 않는다면 교착상태는 발생하지 않는다. 조금 전 예사에서 공유자원을 찾아보자. 예시에서 공유자원은 도로이다. 공유되는 도로를 서로 차지하려다가 교착상태가 발생한 것이다.

이제 교착상태를 설명하는 유명한 예시를 한번 살펴보자. 바로 '식사하는 철학자'이다. 원형으로 된 탁자에서 맛있는 음식이 준비되어 있고 의자가 3개 놓여져 있다. 철학자 3명은 각자 의자에 앉아서 음식을 먹으려고 하는데 포크는 3개밖에 없다. 음식을 먹으려면 포크 2개를 사용해야 한다. 음식을 먹으려는 철학자는 좌우에 있는 포크를 집어서 음식을 먹어야 한다. 그동안 다른 철학자는 음식을 먹지 않고 대기를 하면서 책을 읽는다. 이렇게만 식사가 이루어지면 아무런 문제가 발생하지 않는다. 하지만 문제가 발생한다. 우연히 철학자 3명이 동시에 자기 오른쪽에 있는 포크를 동시에 집었다. 모든 철학자에게 포크가 1개 더 필요한 상황이다. 그런데 아무도 양보하지 않아서 더 이상 식사가 불가능한 교착상태에 빠진다.

그러면 교착상태 필요조건은 무엇일까? 4가지가 존재하는데 이 중 1개라도 충족하지 않는다면 교착상태는 발생하지 않는다. 그럼 4가지 조건을 살펴보자. 첫째, 상호배제이다. 어떤 프로세스가 한 리소스를 점유했다면 그 리소스는 다른 프로세스에게 공유를 할 수 없다. 식사하는 철학자에서 포크가 이에 해당한다. 먼저 포크를 집헝ㅆ다면 그 포크는 다른 철학자에게 공유할 수 없는 리소스이다. 둘째, 비선점이다. 프로세스 A가 리소스를 점유하고 있는데 프로세스 B가 리소스를 뺏을 수 없어야 한다. 식사하는 철학자에서 철학자 A가 들고 있는 포크를 철학자 B가 뺏을 수 없는 상황이다. 셋째, 점유와 대기이다. 어떤 프로세스가 리소스 A를 가지고 있는 상태에서 리소스 B를 원하는 상황이어야 한다. 식사하는 철학자에서 오른쪽 포크를 손에 쥔 채로 왼쪽 포크를 기다리고 있는 상태여야 한다. 넷째, 원형대기이다. 원형대기는 점유와 대기를 하는 프로세스들의 관계가 원형을 이루고 있다는 것이다. 식사하는 철학자에서 서로가 서로의 포크를 원하는 상황이 원형을 이루고 있다.

지금까지 알아 본 교착상태의 필요조건에서 한 가지라도 충족하지 않는다면 교착상태는 발생하지 않는다. 운영체제를 연구하는 사람들은 이것을 이용하여 교착상태를 예방하려고 했으나 제약이 많고 굉장히 비효율적이라 다른 방식을 연구했다. 바로 교착상태에 빠졌을 때 해결하는 방식으로 연구하였다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 데드락 해결

교착상태 해결방법으로 교착상태 회피라는 방법이 존재한다. 프로세스들에게 자원을 할당할 때 어느 정도 자원을 할당해야 교착상태가 발생하는지 파악해서 교착상태가 발생하지 않는 수준의 자원을 할당한다. 교착상태 회피는 전체 자원의 수와 할당된 자원의 수를 기준으로 안전상태와 불안정상태로 나뉜다. 운영체제가 최대한 안정상태를 유지하려고 자원을 할당한다. 그런데 불안정 상태에 빠지더라도 무조건 교착상태에 빠지는 것이 아니라 교착상태에 빠질 확률이 높아지는 것이다.

이제 교착상태 회피를 표현한 알고리즘을 살펴보겠다. 은행원 알고리즘이라는 은행이 대출해주는 상식적인 방법의 알고리즘이다. 은행에 돈이 1000만 원 있다고 가정하자. 사업가 A는 은행에서 500만 원 대출을 한다. 사업가 B도 은행에서 400만 원 대출을 한다. 그럼 은행에는 100만 원의 자금이 남는다. 시간이 지나서 은행은 사업가 A에게 돈을 갚으라고 말하지만 사업가 A는 지금은 못 갚고 200만 원만 더 대출해 주면 그걸로 돈을 벌어서 갚는다고 말한다. 은행은 현재 잔고가 100만 원밖에 없기 때문에 사업가 B에게 돈을 받아서 빌려주려고 생각을 한다. 그래서 사업가 B에게 돈을 갚으라고 말하지만 사업가 B도 200만 원만 더 빌려주면 그걸로 돈을 갚는다고 한다. 은행은 현재 누구에게도 돈을 빌려주지 못하고 돈을 받지도 못하는 교착상태에 빠진다. 은행은 이러한 상황을 피하기 위해 사업가들에게 돈을 빌려줄 때 은행의 여유돈과 사업가들에게 빌려준 돈을 보고 대출가능한 상황(안정상태)인지 확인하고 빌려주는데 이것을 은행원 알고리즘이라고 한다.

그럼 운영체제에서 은행원 알고리즘을 구현하는 법을 살펴보자. 운영체제는 프로세스들에게 자원을 할당하기 전에 자기가 기지고 있는 전체 자원의 수를 알고 있어야 한다. 이를 '시스템의 총 자원'이라고 부른다. 그리고 프로세스들은 각자 자기가 필요한 자원의 최대 숫자를 운영체제에게 알려줘야 한다. 이것을 '최대 요구 자원'이라고 부른다.

그럼 안정상태를 먼저 살펴보자.  운영체제가 가지고 있는 자원의 수, 시스템의 총 자원은 14개라고 가정하자. 그리고 각 프로세스가 요구하는 자원과 할당된 자원, 요청이 예상되는 자원은 아래와 같다 하자.

| 프로세스 | 최대 요구 자원 | 현재 할당된 자원 | 요청이 예상되는 자원 |
| -------- | -------------- | ---------------- | -------------------- |
| p1       | 9              | 5                | 4                    |
| p2       | 6              | 4                | 2                    |
| p3       | 4              | 3                | 1                    |

현재 안정상태인 운영체제는 시스템 총 자원 14개에서 할당된 자원을 빼면 2개가 남는다. 이 자원을 가지고 프로세스들의 요청이 예상되는 자원을 제공한다. 만약 p1이 4개를 요청하면 현재 사용 가능한 자원은 2개이기 때문에 p1의 요청을 거부하고 p2의 요청을 받는다. p2는 2개를 요청했기 때문에 사용가능한 2개 자원을 전부 p2에게 할당하고 p2는 할당된 자원을 가지고 작업을 마치고 6개를 반납한다.

| 프로세스 | 최대 요구 자원 | 현재 할당된 자원 | 요청이 예상되는 자원 |
| -------- | -------------- | ---------------- | -------------------- |
| p1       | 9              | 5                | 4                    |
| p2       | 6              | 6                | 0                    |
| p3       | 4              | 3                | 1                    |

그럼 이제 사용 가능한 자원이 6개로 늘어났기 때문에 p3가 요청한 1개와 p1이 요청한 4개를 전부 할당이 가능하다.

그럼 불안정 상태를 확인해보자.

| 프로세스 | 최대 요구 자원 | 현재 할당된 자원 | 요청이 예상되는 자원 |
| -------- | -------------- | ---------------- | -------------------- |
| p1       | 9              | 7                | 2                    |
| p2       | 6              | 4                | 2                    |
| p3       | 4              | 2                | 2                    |

운영체제의 시스템 총자원이 14개라고 하고 현재 할당된 자원을 제외하면 여유 자원은 1개가 남는다. 이 자원으로 p1, p2, p3가 요청할 수 있는 최대 요청인 2개를 충족하지 못한다. 이 상태를 불안정 상태라고 부른다. 불안정 상태에 있더라도 모든 프로세스가 최대 자원을 요청하지 않는다면 교착상태에 빠지지 않을 수도 있지만 불안정 상태에 빠지지 않도록 하는 것이 좋다. 은행원 알고리즘은 교착상태를 피하는 좋은 방법이지만 비용이 비싸고 비효율적이다. 그래서 운영체제를 연구하는 사람들은 교착상태의 발생은 허용하지만 교착상태가 발생하였을 때 이를 해결하는 방식을 연구했다.

운영체제를 연구하는 사람들은 어떻게 교착상태를 검출할 지부터가 고민이었다. 고민결과, 두 가지 방식으로 검출할 수 있다는 사실을 알게 되었다. 첫째, '가벼운 교착상태 검출'이다. 이 방식은 타이머를 이용하는 방식인데 프로세스가 일정시간 동안 작업을 진행하지 않는다면 교착상태가 발생했다고 간주하고 교착상태를 해결한다. 교착상태를 해결하는 방법은 간단하다. 일정 시점마다 체크포인트를 만들어 작업을 저장하고 타임아웃으로 교착상태가 발생했다면 마지막으로 저장했던 체크포인트로 롤백하는 것이다. 게임을 하다 보면 게임의 이전 버전이나 서버를 롤백 혹은 빽섭했다고 말을 하는데 이와 동일한 메커니즘이다. 둘째, '무거운 교착상태 검출'이다. 이 방식은 자원 할당 그래프를 이용하는데 현재 운영체제에서 프로세스가 어떤 자원을 사용하는지 지켜보고 교착상태가 발생했다면 해결하는 방식이다. 그러면 그래프를 이용해서 어떻게 교착상태 발생여부를 확인할까? 프로세스들은 각자 자원을 차지하고 있고 다른 자원들을 요청한다. 만약 이 구조가 순환구조가 생기지 않는 그래프형으로 띄면 교착상태가 발생하지 않은 것이고 순환구조 그래프가 발생했다면 교착상태가 발생한 것이다. 이렇게 교착상태를 검출했다면 교착상태를 일으킨 프로세스를 강제 종료한다. 그리고 다시 실행시킬 때 체크포인트로 롤백한다. 이 방식은 운영체제가 지속적으로 자원 할당 그래프를 유지하고 검사해야 하기 때문에 오버헤드가 발생하지만 가벼운 교착상태 검출에서 발생할 수 있는 억울하게 종료되는 프로세스는 발생하지 않는다.

> 억울하게 종료되는 프로세스: 예를 들어 입출력 작업으로 프로세스가 대기상태에 빠졌는데 이를 운영체제는 교착상태로 빠졌다고 착각하기 쉽다.
