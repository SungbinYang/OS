> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 운영체제 개요

오늘날 운영체제가 쓰이는 곳이 굉장히 많아졌다. 개인용 PC에는 Windows나 MAC 운영체제가 쓰이고, 대형 PC나 서버용 PC는 유닉스나 리눅스 운영체제가 쓰인다. 스마트폰, 태블릿에는 안드로이드나 ios 운영체제가 쓰이며, 스마트워치, 세탁기, 냉장고, 에어컨, 내비게이션등은 임베디드 운영체제가 쓰인다.

> Q. 컴퓨터는 운영체제가 있어야 동작하는가?  
> A. 없어도 동작한다.

위의 질의응답에 대해 추가적인 의견을 붙여보겠다. 운영체제가 없어도 동작은 하지만 없으면 처음 설계한 그대로만 동작할 뿐 다른 기능들을 추가할 수 없다. 과거의 유선 전화기를 생각해보면 이해가 될 것이다. 과거 유선 전화기는 '통화'라는 기능만 작동되고 그 외 다른 기능은 없었지만 오늘날 스마트폰은 어플을 다운로드하여 통화기능 외에 다른 기능들을 추가할 수 있다.

### 운영체제가 하는 일 (관리하는 일)

운영체제가 하는 첫번째 기능은 **프로세스를 관리**해준다. 우리가 PC를 켜서 인터넷 브라우저를 켜서 쇼핑을 하면서 음악 플레이어를 켜서 음악도 듣고 그와 동시에 게임을 실행시켜서 게임을 하듯이 동시 실행이 가능하다. 게임을 하는 중에는 키보드나 마우스 같은 입력기기들은 게임에만 동작해야 하고 나머지는 백그라운드에 동작해야 한다. 만약, 운영체제가 관리를 해주지 않으면 특정 프로그램이 CPU를 독차지하여 다른 프로그램들이 작동하지 않을 것이다.

둘째, **메모리 관리**이다. 모든 프로그램은 메모리에 올라와서 동작을 한다. 오늘날 운영체제는 여러 프로그램을 동시실행을 하기 때문에 여러 프로그램들이 메모리에 올라와서 동작을 한다.

셋째, **하드웨어 관리**이다. 운영체제는 사용자의 직접적인 하드웨어 접근을 금지한다. 하드웨어에 데이터 저장 시, 특정영역에 저장하는 행위를 막는다. 운영체제가 알아서 적절한 위치에 저장을 시켜준다. 그 이유는 하드웨어 특정영역에 다른 중요한 데이터가 있을 수 있고 사용자의 악의적인 공격 행위를 막기 위해서이다.

넷째, **파일시스템 관리**이다. 하드웨어에 많은 파일들을 효율적으로 저장하고 관리해 준다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 운영체제의 역사

운영체제의 역사를 살펴보자. 역사를 보면 오늘날 운영체제가 왜 이렇게 복잡해졌는지 이해가 가능할 것이다.

### 1940년

최초의 PC **에니악**은 1943년도 미군지휘하에 미국 펜실베니아 대학에서 만들어졌다. 처음 목적은 미사일 탄도 계산이 목적이였다. 에니악은 세계에서 가장 큰 스케일의 전자 디지털 계산기이다. 에니악은 특정 명령에 맞는 스위치와 배선을 연결하여 프로그래밍을 하였다. 특정문제가 있으면 종이로 작업을 하고 테스트를 거친 후(몇 주) 종이를 보고 스위치와 배선을 연결하는 방식이였다. 또한 입출력을 위해 IBM 펀치카드를 이용하였는데 이 방식은 굉장히 입출력 속도가 느렸고 입출력 도중에 계산이 불가능하였다. 또한 에니악은 수 많은 진공관이 존재했고 이를 공냉식으로 열을 식혔지만 작업 도중 터질 우려가 있고 터지면 바로 교체를 해줘야 했다. 이에 컴퓨터를 연구하는 개발자분들은 어떻게 하면 에니악에 들어간 CPU를 많이 쓸 수 있을까 고민을 하기 시작했다.

### 1950년 초

진공관과 전선으로 만들어진 논리회로를 아주 작은 크기로 만든 **직접회로(IC)**가 개발이 되었다. 이로써 현대적인 PC에 가까워졌다. 이 때는 CPU와 메모리가 있었지만 키보드와 모니터가 없었고, 대신 펀치카드를 이용하여 개발자가 카드에 구멍을 뚫어 프로그래밍을 하면 컴퓨터가 카드를 읽어 계산하고 결과는 라인 프린터로 출력되는 방식이였다. 기존 에니악의 스위치와 배선작업을 하는 것보다 훨씬 편해졌다.

### 1950년 중후반

이전가지는 개발자가 펀치카드를 이용하여 프로그래밍을 하면 오퍼레이터가 직접 컴퓨터에 카드를 넣고 결과가 나오면 개발자에게 전달하는 방식이였다. 이 방식은 컴퓨터의 처리속도보다 오퍼레이터 전달이 상대적으로 느리게 느껴졌다. 즉, 오퍼레이터의 오버헤드가 너무 컸다. 그래서 개발자가 여러개의 펀치카드를 전달하면 오퍼레이터는 이를 모아서 한번에 컴퓨터에게 전달했고 컴퓨터는 이를 순차적으로 실행시켜서 라인프린터로 결과가 나오면 이를 오퍼레이터가 다시 전달하는 방식으로 변경되었다. 이 방식을 **싱글 스트림 배치 시스템**이라고 한다. 싱글 스트림 배치 시스템은 여러개의 작업을 하는데 작업이 끝날 때마다 일일이 오퍼레이터가 결과를 꺼내고 다시 다른 프로그램을 실행시키는 이런 비효율적인 과정이 없어졌고 CPU의 사용률은 증가하였다.

여기서 컴퓨터 시스템 개발자들은 CPU의 사용률을 더 극대화 시킬려고 노력했다. 이 때는 입출력 작업동안 CPU를 사용할 수 없었는데 I/O 디바이스 컨트롤러를 만들어 I/O도중에도 CPU를 계산할 수 있게 하였다. I/O 디바이스 컨트롤러는 입출력 작업이 끝나면 CPU에게 인터럽트 신호를 주고 인터럽트를 받은 CPU는 이를 다시 처리하는 방식으로 변경되었다. 문제는 CPU와 I/O 디바이스 컨트롤러를 나눴어도 CPU를 기다리는 작업이 필요했는데 바로 입력때 발생하였다. 출력은 I/O 디바이스 컨트롤러를 이용해서 CPU와 분리가 가능하지만 입력인 경우에는 어쩔 수 없이 기다려야 하기 때문에 CPU 사용률을 떨어트렸다. 이것이 싱글 스트림 배치 시스템의 한계이다.

### 1960년

싱글 스트림 배치 시스템의 한계를 극복하기 위해 프로그램을 순서대로 하나씩 실행하지 않고 메모리에 여러 프로그램을 올려놓고 시간을 나누어 빠르게 돌아가며 실행하는 방식으로 변경하였다. 매우 빠르게 번갈아 가면서 실행하기 때문에 사용자는 동시에 실행하는 것처럼 착각하는데 이를 **시분할 시스템**이라 불린다. 만약 A프로그램이 입력을 하고 있으면 CPU는 쉬지 않고 B,C프로그램을 실행시키기 때문에 CPU 사용률이 증가하게 되었다. 이로 인해 프로그램을 동시에 여러개 실행이 가능해졌고 이로 인해 여러 사용자가 한번에 사용이 가능하게 되었다.

컴퓨터는 비싸서 하나의 컴퓨터에 여러 터미널(단말기)를 붙여서 여러 사용자들이 접근하여 사용하였다. 이로 인해 컴퓨터에 개인이 필요한 문서같은 개인정보를 저장하기 시작하였고 이 때문에 **파일시스템**이 등장하게 되었다.

이 당시 C언어로 개발된 유닉스 운영체제가 개발이 되었는데 이 운영체제가 조금 전에 설명한 프로그램을 동시에 여러개 실행시키는 **멀티프로그래밍**과 여러 사용자를 지원하는 **다중 사용자**와 **파일시스템**을 구현한 운영체제이다.

하지만 여러 프로그램을 동시에 실행시켰을 때 다양한 문제가 발생하였다. 첫째, 메모리에 여러 프로그램이 올라와서 작업이 실행되기 때문에 프로그램 간 **메모리 침법이슈** 문제가 발생하였다. 메모리 침법으로 원하지 않는 결과가 발생하기도 하였다.(ex. 블루스크린) 둘째, 기존에는 프로그램을 작성할 때 메모리에는 프로그램이 하나였기 때문에 메모리 주소를 프로그램이 하나라고 가정하고 프로그래밍을 했는데 이제는 여러개가 올라가니 프로그램을 **어느 메모리 위치에 실행시켜야 하는지 모르게 되었다.** 그래서 하드웨어적으로 **베이스 레지스터**라는 것을 추가하여 프로그램 시작주소를 저장시키고 모든 프로그램은 항상 **0번지에 시작**한다고 가정하고 실행시켰다. 이로 인해 CPU 사용률을 증대시켰다.

### 1970년

개인용 PC가 보급이 되기 시작했다. 이 당시에는 Apple의 매킨토시와 MS의 MS-DOC를 많이 이용하였다.
