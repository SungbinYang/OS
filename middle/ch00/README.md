> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 운영체제 개요

오늘날 운영체제가 쓰이는 곳이 굉장히 많아졌다. 개인용 PC에는 Windows나 MAC 운영체제가 쓰이고, 대형 PC나 서버용 PC는 유닉스나 리눅스 운영체제가 쓰인다. 스마트폰, 태블릿에는 안드로이드나 ios 운영체제가 쓰이며, 스마트워치, 세탁기, 냉장고, 에어컨, 내비게이션등은 임베디드 운영체제가 쓰인다.

> Q. 컴퓨터는 운영체제가 있어야 동작하는가?  
> A. 없어도 동작한다.

위의 질의응답에 대해 추가적인 의견을 붙여보겠다. 운영체제가 없어도 동작은 하지만 없으면 처음 설계한 그대로만 동작할 뿐 다른 기능들을 추가할 수 없다. 과거의 유선 전화기를 생각해보면 이해가 될 것이다. 과거 유선 전화기는 '통화'라는 기능만 작동되고 그 외 다른 기능은 없었지만 오늘날 스마트폰은 어플을 다운로드하여 통화기능 외에 다른 기능들을 추가할 수 있다.

### 운영체제가 하는 일 (관리하는 일)

운영체제가 하는 첫번째 기능은 **프로세스를 관리**해준다. 우리가 PC를 켜서 인터넷 브라우저를 켜서 쇼핑을 하면서 음악 플레이어를 켜서 음악도 듣고 그와 동시에 게임을 실행시켜서 게임을 하듯이 동시 실행이 가능하다. 게임을 하는 중에는 키보드나 마우스 같은 입력기기들은 게임에만 동작해야 하고 나머지는 백그라운드에 동작해야 한다. 만약, 운영체제가 관리를 해주지 않으면 특정 프로그램이 CPU를 독차지하여 다른 프로그램들이 작동하지 않을 것이다.

둘째, **메모리 관리**이다. 모든 프로그램은 메모리에 올라와서 동작을 한다. 오늘날 운영체제는 여러 프로그램을 동시실행을 하기 때문에 여러 프로그램들이 메모리에 올라와서 동작을 한다.

셋째, **하드웨어 관리**이다. 운영체제는 사용자의 직접적인 하드웨어 접근을 금지한다. 하드웨어에 데이터 저장 시, 특정영역에 저장하는 행위를 막는다. 운영체제가 알아서 적절한 위치에 저장을 시켜준다. 그 이유는 하드웨어 특정영역에 다른 중요한 데이터가 있을 수 있고 사용자의 악의적인 공격 행위를 막기 위해서이다.

넷째, **파일시스템 관리**이다. 하드웨어에 많은 파일들을 효율적으로 저장하고 관리해 준다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 운영체제의 역사

운영체제의 역사를 살펴보자. 역사를 보면 오늘날 운영체제가 왜 이렇게 복잡해졌는지 이해가 가능할 것이다.

### 1940년

최초의 PC **에니악**은 1943년도 미군지휘하에 미국 펜실베니아 대학에서 만들어졌다. 처음 목적은 미사일 탄도 계산이 목적이였다. 에니악은 세계에서 가장 큰 스케일의 전자 디지털 계산기이다. 에니악은 특정 명령에 맞는 스위치와 배선을 연결하여 프로그래밍을 하였다. 특정문제가 있으면 종이로 작업을 하고 테스트를 거친 후(몇 주) 종이를 보고 스위치와 배선을 연결하는 방식이였다. 또한 입출력을 위해 IBM 펀치카드를 이용하였는데 이 방식은 굉장히 입출력 속도가 느렸고 입출력 도중에 계산이 불가능하였다. 또한 에니악은 수 많은 진공관이 존재했고 이를 공냉식으로 열을 식혔지만 작업 도중 터질 우려가 있고 터지면 바로 교체를 해줘야 했다. 이에 컴퓨터를 연구하는 개발자분들은 어떻게 하면 에니악에 들어간 CPU를 많이 쓸 수 있을까 고민을 하기 시작했다.

### 1950년 초

진공관과 전선으로 만들어진 논리회로를 아주 작은 크기로 만든 **직접회로(IC)**가 개발이 되었다. 이로써 현대적인 PC에 가까워졌다. 이 때는 CPU와 메모리가 있었지만 키보드와 모니터가 없었고, 대신 펀치카드를 이용하여 개발자가 카드에 구멍을 뚫어 프로그래밍을 하면 컴퓨터가 카드를 읽어 계산하고 결과는 라인 프린터로 출력되는 방식이였다. 기존 에니악의 스위치와 배선작업을 하는 것보다 훨씬 편해졌다.

### 1950년 중후반

이전가지는 개발자가 펀치카드를 이용하여 프로그래밍을 하면 오퍼레이터가 직접 컴퓨터에 카드를 넣고 결과가 나오면 개발자에게 전달하는 방식이였다. 이 방식은 컴퓨터의 처리속도보다 오퍼레이터 전달이 상대적으로 느리게 느껴졌다. 즉, 오퍼레이터의 오버헤드가 너무 컸다. 그래서 개발자가 여러개의 펀치카드를 전달하면 오퍼레이터는 이를 모아서 한번에 컴퓨터에게 전달했고 컴퓨터는 이를 순차적으로 실행시켜서 라인프린터로 결과가 나오면 이를 오퍼레이터가 다시 전달하는 방식으로 변경되었다. 이 방식을 **싱글 스트림 배치 시스템**이라고 한다. 싱글 스트림 배치 시스템은 여러개의 작업을 하는데 작업이 끝날 때마다 일일이 오퍼레이터가 결과를 꺼내고 다시 다른 프로그램을 실행시키는 이런 비효율적인 과정이 없어졌고 CPU의 사용률은 증가하였다.

여기서 컴퓨터 시스템 개발자들은 CPU의 사용률을 더 극대화 시킬려고 노력했다. 이 때는 입출력 작업동안 CPU를 사용할 수 없었는데 I/O 디바이스 컨트롤러를 만들어 I/O도중에도 CPU를 계산할 수 있게 하였다. I/O 디바이스 컨트롤러는 입출력 작업이 끝나면 CPU에게 인터럽트 신호를 주고 인터럽트를 받은 CPU는 이를 다시 처리하는 방식으로 변경되었다. 문제는 CPU와 I/O 디바이스 컨트롤러를 나눴어도 CPU를 기다리는 작업이 필요했는데 바로 입력때 발생하였다. 출력은 I/O 디바이스 컨트롤러를 이용해서 CPU와 분리가 가능하지만 입력인 경우에는 어쩔 수 없이 기다려야 하기 때문에 CPU 사용률을 떨어트렸다. 이것이 싱글 스트림 배치 시스템의 한계이다.

### 1960년

싱글 스트림 배치 시스템의 한계를 극복하기 위해 프로그램을 순서대로 하나씩 실행하지 않고 메모리에 여러 프로그램을 올려놓고 시간을 나누어 빠르게 돌아가며 실행하는 방식으로 변경하였다. 매우 빠르게 번갈아 가면서 실행하기 때문에 사용자는 동시에 실행하는 것처럼 착각하는데 이를 **시분할 시스템**이라 불린다. 만약 A프로그램이 입력을 하고 있으면 CPU는 쉬지 않고 B,C프로그램을 실행시키기 때문에 CPU 사용률이 증가하게 되었다. 이로 인해 프로그램을 동시에 여러개 실행이 가능해졌고 이로 인해 여러 사용자가 한번에 사용이 가능하게 되었다.

컴퓨터는 비싸서 하나의 컴퓨터에 여러 터미널(단말기)를 붙여서 여러 사용자들이 접근하여 사용하였다. 이로 인해 컴퓨터에 개인이 필요한 문서같은 개인정보를 저장하기 시작하였고 이 때문에 **파일시스템**이 등장하게 되었다.

이 당시 C언어로 개발된 유닉스 운영체제가 개발이 되었는데 이 운영체제가 조금 전에 설명한 프로그램을 동시에 여러개 실행시키는 **멀티프로그래밍**과 여러 사용자를 지원하는 **다중 사용자**와 **파일시스템**을 구현한 운영체제이다.

하지만 여러 프로그램을 동시에 실행시켰을 때 다양한 문제가 발생하였다. 첫째, 메모리에 여러 프로그램이 올라와서 작업이 실행되기 때문에 프로그램 간 **메모리 침법이슈** 문제가 발생하였다. 메모리 침법으로 원하지 않는 결과가 발생하기도 하였다.(ex. 블루스크린) 둘째, 기존에는 프로그램을 작성할 때 메모리에는 프로그램이 하나였기 때문에 메모리 주소를 프로그램이 하나라고 가정하고 프로그래밍을 했는데 이제는 여러개가 올라가니 프로그램을 **어느 메모리 위치에 실행시켜야 하는지 모르게 되었다.** 그래서 하드웨어적으로 **베이스 레지스터**라는 것을 추가하여 프로그램 시작주소를 저장시키고 모든 프로그램은 항상 **0번지에 시작**한다고 가정하고 실행시켰다. 이로 인해 CPU 사용률을 증대시켰다.

### 1970년

개인용 PC가 보급이 되기 시작했다. 이 당시에는 Apple의 매킨토시와 MS의 MS-DOC를 많이 이용하였다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 운영체제의 구조

운영체제의 핵심은 **커널**이다. 커널은 프로세스와 메모리, 저장장치를 관리해 주는 핵심기능을 담당한다. 사용자는 운영체제의 커널에 직접 접근이 불가능하고 장치를 추상화한 파일 형태의 인터페이스를 통해 접근이 가능하다. 인터페이스는 GUI, CLI 2개로 나눠지는데 텍스트냐 그림이냐 차이만 있을 뿐 커널에 접근하기 위한 목적은 같다.

> 1\. GUI: Graphic User Interface의 약자로 그래픽으로 된 인터페이스다. Windows와 MAC과 같이 그래픽으로 커널과 상호작용하기 때문에 일반 사용자가 쓰기 쉽다.
>
> 2\. CLI: Command Line Interface의 약자로 유닉스나 리눅스 같은 운영체제가 기본적으로 제공하는 인터페이스로 텍스트를 통해 커널과 상호작용을 한다.

프로그램은 **시스템 콜**을 통해 커널에 접근할 수 있다. 커널은 사용자로부터 자신을 보호하기 위한 시스템 콜이라는 인터페이스를 지닌다. 시스템 콜 없이 프로그램이 하드웨어에 직접 접근을 하게 되면 중요한 데이터가 날아가거나 다른 애플리케이션 데이터를 덮어쓸 수 있다. 시스템 콜을 이용하면 커널에서 제공하는 write함수를 쓰게 되는데 이 함수를 호출하면 운영체제가 알아서 하드디스크 빈 공간에 저장시켜 준다.

하드웨어와 커널 간의 인터페이스로는 **드라이버**가 있다. 운영체제는 많은 하드웨어를 지원한다. 하지만 각 하드웨어에 맞는 프로그램을 커널이 미리 가지고 있기 힘들고 보통은 제조사가 제공을 해주기 마련이다. 그래서 기본적인 키보드, 마우스 같은 드라이버는 포함되어 있지만 그래픽 카드 같은 드라이버는 설치를 해야 한다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 컴퓨터 하드웨어와 구조

오늘날 PC는 프로그램 내장방식의 **폰 노이만 구조**를 사용한다. 예전에는 에니악과 같이 하드웨어로 프로그램을 만들었기에 프로그램이 달라질 때마다 스위치와 배선을 다시 조정하였다. 폰 노이만은 이걸 해결하기 위해 CPU와 메모리를 두고 이 둘 사이에는 버스로 연결시켰다.

> 버스: 데이터 전달 통로

프로그램은 메모리에 올려서 실행시키는데 프로그램을 메모리에 내장했다고 해서 프로그램 내장방식이라고 불린다. 메모리에 올라간 프로그램은 명령에 따라 처리되고 배선을 바꾸는 대신에 S/W만 바꾸면 되기 때문에 상당히 편리하다.

### 컴퓨터 하드웨어

오늘날 PC의 기본이 되는 것은 메인보드이다. 메인보드는 다른 하드웨어를 연결하는 장치이다. 장치 간에 데이터 전속하는 것은 메인보드의 버스가 담당한다. 폰 노이만 구조이니까 CPU와 메모리가 필수적이다. CPU와 메모리를 메인보드에 장찰하고 하드디스크 연결단자에 하드디스크를 연결하고 그래픽 카드, 모니터, 마우스, 키보드, 스피커등을 연결하면 우리가 생각하는 컴퓨터의 모습이 된다.

### CPU 구조

CPU란 중앙처리장치이다. CPU에는 산술논리연산장치(ALU), 제어장치, 레지스터로 구성된다.

> 1\. 산술논리연산장치(ALU): 실제로 데이터 연산을 담당  
> 2\. 제어장치: 모든 장치의 동작을 지시하고 제어한다.  
> 3\. 레지스터: CPU내의 계산을 위해 임시로 보관하는 장치, 일종의 변수이다.

### 메모리 종류

메모리 종류에는 RAM과 ROM으로 나눈다. RAM은 랜덤으로 데이터를 읽어도 저장위치에 관계없이 읽는 속도가 일정하며, RAM은 전력이 끊기면 날아가는 휘발성 메모리이기에 메인 메모리로 사용된다. ROM은 전력이 끊겨도 데이터를 계속 보관이 가능하지만 한번 데이터를 쓰면 수정이 불가능하기 때문에 컴퓨터 부팅과 관련된 바이오스를 저장시키는 데 사용한다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 컴퓨터 부팅 과정

컴퓨터의 전원을 누르면 ROM에 저장된 바이오스가 실행된다. 바이오스는 컴퓨터의 전원, 메모리, CPU, 키보드, 마우스, 하드디스크등 주요 하드웨어에 이상이 없는지를 체크한다. 만약 주요 장치에 이상이 있다면 오류음을 내면서 부팅이 되지를 않는다. 이상이 없다면 HDD에 있는 0번 섹터 0번 트랙의 마스터 부트 레코드에 부트로더를 메모리로 가져와 실행시킨다. 만약 운영체제가 2개 이상 설치된 PC라면 선택 화면이 나온다. 선택을 하였거나 운영체제가 1개라면 바로 운영체제를 메모리로 불러오고 모니터에 바탕화면이 나오게 된다. 이제부터 실행되는 프로그램은 메모리에 올려서 운영체제가 관리하게 된다.
