> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## CPU 스케줄링 개요

컴퓨터의 자원은 다음과 같다. CPU와 메모리 같은 필수장치와 하드디스크, 키보드, 마우스와 같은 주변장치가 있다. 이번시간부터 필수장치인 CPU에 대해 알아보자. 프로그램을 실행시키면 메모리에 프로세스가 생성되고 각 프로세스에는 1개 이상의 쓰레드가 존재한다. 프로세스들은 CPU를 할당/해제하는데 이를 CPU 스케줄링이라고 한다.

CPU 스케줄링에서 스케줄러(운영체제)가 고려해야 할 사항은 2가지이다. 첫째, "어떤 프로세스에게 CPU 리소스를 줘야하는가?"이다. 메모리에는 수많은 프로세스들이 있는데 여기서 "어떤 프로세스에게 CPU 사용권을 줘야 하는가?" 하는 문제이다. 한 프로세스에게만 계속 할당하면 다른 프로세스들이 불만을 제기할 것이다. 둘째, "CPU를 할당받은 프로세스가 얼마의 시간 동안 CPU를 사용해야 하는가?"이다. 오늘날은 시분할 처리방식으로 여러 프로세스에게 짧은 시간 동안 돌아가면서 CPU를 할당한다. 예를 들어 프로세스 A에게 1초 동안 CPU 이용권을 주고 1초가 지나면 CPU를 뺏어서 프로세스 B에게 1초 동안 CPU 이용권을 주는 방식이다. 지금 말한 이 2가지 고려사항이 컴퓨터 성능에 굉장히 큰 영향을 끼친다.

> CPU를 할당받아 실행하는 작업을 CPU Burst, 입출력 작업을 I/O Burst라고 한다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 다중 큐

이전에 배웠던 프로세스 상태를 다시 살펴보겠다. 프로세스가 생성되면 준비상태로 전환되고 준비상태에서 CPU를 기다리고 있는 프로세스들은 CPU 스케줄러에 의해 실행상태로 전환된다. 실행상태에 있는 프로세스는 CPU 할당시간이 다 되면 다시 준비상태로 전환되고 입출력 요청이 있다면 대기상태로, 작업이 완료되었다면 완료상태로 전환된다. 여기서 프로세스가 대기하고 있는 준비상태와 대기상태는 큐라는 자료구조로 관리된다. 큐 자료구조는 우리가 마트 계산대에 줄을 서는 것과 같이 먼저 온 사람이 가장 먼저 처리를 받고 나중에 온 사람은 나중에 처리를 받는 구조이다. 먼저 들어온 게 나중에 처리받고 나중에 들어온 게 먼저 처리받는 스택이랑 상반된 구조이다.

프로세스가 실행상태에서 준비상태로 돌아갈 때 운영체제는 해당 프로세스의 우선순위를 보고 그에 맞는 "준비 큐"에 넣는다. CPU 스케줄러는 "준비상태의 다중 큐"에 들어있는 프로세스들 중에 적당한 프로세스를 선택해서 실행상태로 전환시킨다. 프로세스가 실행상태에서 입출력 요청을 받아 대기상태로 오면 입출력 요청에 따라서 분류 된 큐에 들어가게 된다. 예를 들면, HDD 작업은 "HDD 큐"에 넣고 HDD 작업이 완료되어 인터럽트가 날아가면 HDD 큐를 뒤져서 다시 꺼내갑니다. 지금까지 큐에 프로세스가 들어간다고 했는데 정확히는 프로세스의 정보를 가지는 PCB가 들어가 있다.

정리를 해보겠다. 프로세스 정보를 담고 있는 PCB는 준비상태의 다중 큐에 들어가서 실행되기를 기다리고 있고 CPU 스케줄러에 의해 실행상태로 전환된다. 이 때 CPU 스케줄러는 준비상태의 다중 큐를 참조해서 어떤 프로세스를 실행시킬지 결정을 한다. 입출력 작업도 비슷하다. 실행 중인 프로세스에게 입출력 작업이 발생하면 해당 입출력 작업의 종류 별로 나뉜 큐에 들어가고 CPU 스케줄러는 이를 참조해서 스케줄링한다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 스케줄링 목표

스케줄링 목표는 여러가지가 존재한다. 첫째, **리소스 사용률**이다. CPU 사용률을 높이는 것을 목표로 할 수도 있고 I/O 디바이스의 사용률을 높이는 것을 목표로 할 수 있다. 둘째, **오버헤드 최소화**이다. 스케줄링을 하기 위한 계산이 너무 복잡하거나 컨텍스트 스위칭을 너무 자주 하면 배보다 배꼽이 더 커지는 상황이 나온다. 스케줄러는 이런 오버헤드를 최소화하는 것을 목표로 한다. 셋째, **공평성**이다. 모든 프로세스에게 공평하게 CPU가 할당되어야 한다. 특정 프로세스에게만 CPU가 계속 할당된다면 불공평할 것이다. 여기서 공평의 의미는 시스템에 따라 달라질 수 있다. 예를 들어 자율주행 자동차에 사용되는 운영체제를 생각해 보면 안전의 이유로 장애물을 인지하고 피하는 프로세스가 가장 중요할 것이다. 그에 비해 음악을 재생하거나 실내 온도 유지 기능은 상대적으로 덜 중요할 것이다. 이 운영체제는 장애물을 인지하고 피하는 프로세스에게 CPU가 많이 할당되는 것이 공평하다. 이와 같은 특수한 경우가 아니라면 모든 프로세스에게 CPU는 골고루 할당되어야 한다. 넷째 **처리량**이다. 같은 시간 내에 더 많은 처리를 할 수 있는 방법을 목표로 한다. 다섯째, **대기시간**이다. 작업을 요청하고 실제 작업이 이루어지기 전까지 대기하는 시간이 짧은 것을 목표로 한다. 여섯째, **응답시간**이다. 대화형 시스템에서 사용자의 요청이 얼마나 빨리 반응하는지가 중요하기 때문에 응답시간이 짧은 것을 목표로 한다.

지금 말한 목표들은 모두 최고의 수준으로 유지하기 힘들다. 그 이유는 목표 간에 서로 상반되는 상황이 있기 때문이다. 예를 들면 처리량을 높이기 위해서는 하나의 프로세스에 CPU를 오래 할당해야 한다. 반면, 응답시간을 줄이기 위해서 여러 프로세스에 골고루 CPU를 할당해야 하는데 이는 서로 상반되기 때문에 처리량과 응답시간의 목표를 같이 달성할 수 없다. 이 때는 사용자가 사용하는 시스템에 따라서 목표를 달리 설정해야 한다. 터치스크린과 같이 사용자에게 빠른 응답이 필요한 경우는 응답시간이 짧도록 초점을 맞추고, 과학계산 같은 경우는 처리량이 높도록 초점을 맞춰야 한다. 일반 사용자의 경우 특별한 목적이 없다면 어느 한쪽에 치우치지 않도록 밸런스를 유지하는 게 중요하다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## FIFO

이번 포스트부터 여러 종류의 CPU 스케줄링 알고리즘을 알아보겠다. 운영체제 설계자들이 생각하는 스케줄링은 처음부터 대단하지 않았다. 우리가 쉽게 생각할 수 있는 것과 크게 다르지 않았다. 가장 먼저 알아볼 알고리즘은 FIFO 알고리즘으로 'First In First Out'의 약자이다. 먼저 들어온 작업이 먼저 나간다는 뜻으로 스케줄링 큐에 들어온 순서대로 CPU를 할당받는 방식이다. 이 방식은 먼저 들어온 프로세스가 완전히 끝나야만 다음 프로세스가 실행된다는 점을 가지고 있다.

마트의 계산대를 생각하면 이해가 쉽다. 카운터에 계산원이 있고 손님들은 장을 보고 카운터 앞에 줄을 선다. 계산원은 먼저 온 손님을 먼저 계산해주는데 이 방식을 FIFO라고 부른다. FIFO 알고리즘의 장점은 단순하고 직관적이라는 것이다. 반대로 단점은 한 프로세스가 완전히 끝나야 다음 프로세스가 시작되기 때문에 실행시간이 짧고 늦게 도착한 프로세스가 실행시간이 길고 빨리 도착한 프로세스의 작업을 기다려야 한다는 것이다. 또한 I/O 작업이 있다고 한다면 CPU는 I/O 작업이 끝날 때까지 쉬고 있기 때문에 CPU 사용률이 떨어진다.

FIFO 알고리즘의 단점을 마트의 예로 확인해보자. 첫 번째 단점으로 실행시간이 길고 일찍 도착한 프로세스와 실행시간이 짧고 늦게 도착한 프로세스의 예이다. 물건 100만 원을 산 손님이 계산대에 먼저 도착했다. 이어서 물건 1000원을 산 손님이 이후에 도착했다고 하자. 현실에서는 첫 손님의 계산시간이 길기 때문에 양해를 구하고 1000원의 물건들을 산 손님부터 계산을 할 수 있다. 하지만 FIFO 알고리즘은 예외 없이 도착한 순서로만 실행순서가 결정되기 때문에 1000원의 물건을 사서 빨리 계산을 마칠 수 있더라도 먼저 온 사람의 계산을 마쳐야 한다는 단점이 있다. 두 번째 단점을 마트의 예로 확인해 보자. 두 번째 단점은 I/O 작업이 있다면 I/O 작업이 끝날 때까지 CPU가 쉬게 되어서 CPU 사용률을 떨어트린다는 점이다. 여기서 I/O 작업은 손님이 지갑을 뒤지는 작업으로 CPU를 계산원이라고 비유하자. 계산원이 손님의 물건을 확인하고 돈을 받으려 한다. 손님은 지갑을 열어 돈을 꺼낸다.(I/O 작업) 동전도 섞여 있어서 시간이 5분 정도 걸렸다. 계산원은 다음 손님의 계산을 도와주지 못하고 기다리기만 해야 한다. 드디어 손님이 돈을 꺼내서 계산이 완료되었다. 이후 1000원의 물건을 산 다음 손님은 굉장히 오래 기다렸다.

스케줄링의 성능은 "평균 대기 시간"으로 평가한다. 평균 대기 시간은 프로세스 여러개 실행될 때 이 프로세스들 모두 실행되기까지 걸리는 대기시간의 평균이다.

| 프로세스       | 프로세스1 | 프로세스2 | 프로세스3 |
| -------------- | --------- | --------- | --------- |
| CPU Burst Time | 25초      | 5초       | 4초       |

위의 표처럼 각 프로세스의 CPU Burst Time이 주어졌다고 하자. 그러면 대기시간은 프로세스 1은 0초, 프로세스 2는 25초, 프로세스 3은 30초로 평균 대기 시간을 구하면 (0 + 25 + 30) / 3 = 18.3초가 나온다. 만약 짧은 순으로 대기시간을 구하면 프로세스 3은 0초, 프로세스 2는 4초, 프로세스 1은 9초로 평균 대기 시간을 구하면 4.3초가 나온다. 프로세스 실행순서만 바꿨는데 평균 대기 시간의 차이가 많이 난다. FIFO 알고리즘은 프로세스의 Burst Time에 따라 성능에 차이가 심하게 나기 때문에 현대 운영체제에서는 잘 사용하지 않고 일괄 처리 시스템에 많이 사용한다.
