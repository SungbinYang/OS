> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 프로세스 간 통신

프로세스는 독립적으로 실행되기도 하지만 다른 프로세스와 데이터를 주고받으며 통신을 하는 경우도 있다. 통신은 한 컴퓨터 내에서 실행되고 있는 다른 프로세스와 할 수도 있고 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와 할 수도 있다.

그럼 프로세스 간 통신의 종류를 알아보자. 첫번째는 한 컴퓨터 내에서 프로세스 간 통신을 하는 방법으로 파일과 파이프를 이용하는 방법이다. 먼저 파일을 이용하는 방법은 통신하려는 프로세스들이 하나의 파일을 이용해 읽고 쓰는 방법이다. 파이프를 이용하는 방법은 운영체제가 생성한 파이프를 이용해 데이터를 읽고 쓰는 방법이다. 두 번째로 쓰레드를 이용하는 방법이 있다. 이 방법은 한 프로세스 내에서 쓰레드들 간 통신을 하는 방법이다. 쓰레드는 코드, 데이터, 힙영역을 공유하고 스택만 각자 자기의 것을 가지고 있다고 했다. 여기서 데이터 영역에 있는 전역변수나 힙을 이용하면 통신이 가능하다. 세 번째로 네트워크를 이용하는 방법이다. 운영체제가 제공하는 소켓통신이나 다른 컴퓨터에 있는 함수를 호출하는 RPC(원격 프로시저 호출)을 이용해 통신하는 방법이 있다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 공유자원과 임계구역

이전 포스트에서 프로세스 간 통신이 가능하다는 것을 알아봤다. 프로세스 간 통신을 할 때 공동으로 이용하는 변수나 파일들이 있는데 이런 것들을 공유자원이라고 한다. 여기서 문제가 발생한다. 공유자원은 여러 프로세스가 공유하고 있기 때문에 각 프로세스의 접근 순서에 따라 어떤 프로세스가 먼저 실행되고 어떤 프로세스가 나중에 실행되는지 예측하기 힘들다. 따라서 연산결과를 예측하기 힘들고 여기서 발생하는 문제를 "**동기화 문제**"라고 부른다.

게임을 예시로 보자. 캐릭터 총체력이 100이고 현재 체력이 20인 상황이라고 하자. 지금은 적에게 공격을 받고 있고 플레이어는 죽지 않기 위해 물약을 먹었다. 이때 물약을 먹는 코드와 적에게 공격받는 코드에서 발생할 수 있는 동기화 문제를 살펴보자.

```c++
int health = 20; // 현재 체력
```

```c++
// 물약을 먹는 코드
int currentHealth = GetHealth();
health = currentHealth + 50; // 체력 50 증가
```

```c++
// 공격 받는 코드
int currentHealth = GetHealth();
health = currentHealth - 10; // 체력 10 감소
```

물약 먹는 코드와 공격 받는 코드가 동시에 실행되었는데 CPU 스케줄러에 의해 공격받는 코드가 먼저 실행되었다고 가정하자. GetHealth()를 호출해서 currentHealth에 20이 저장된다. 여기서 컨텍스트 스위칭을 하여 물약 먹는 코드가 실행되었다고 하자. 물약 먹는 코드에서도 GetHealth()를 통하여 currentHelath에 20이 저장된다. 다음 코드를 실행하여 health 값에 70이 저장된다. 이제 다시 컨텍스트 스위칭을 하여 공격받는 코드가 실행된다. 공격받는 코드의 2번째 줄까지 실행이 되었으니 3번째 줄이 실행되고 health값에는 10이 저장된다. 그래서 결론적으로 60이 저장되어야 한다고 예상을 하지만 결과는 10이 저장된 것이다. 이렇게 결과가 엉망이 된 이유는 health라는 공유자원을 여러 프로세스가 동시에 사용했기 때문이다. 따라서 여러 프로세스가 동시에 사용하면 안 되는 구역을 정의했는데 이를 임계구역이라고 한다. 또한 공유자원을 서로 사용하기 위해 경쟁하는 것을 경쟁조건이라고 한다.

임계구역에서 발생하는 문제를 해결하기 위한 기법의 조건은 무엇일까? 상호배제 메커니즘이 필요한데 조건은 아래와 같은 3가지이다.

> 상호배제 메커니즘 3가지  
> 1\. 주어진 시간에 상상 하나의 프로세스만 임계구역에 접근해야 한다.  
> 2\. 동시에 여러개 요청이 있더라도 하나의 프로세스만 집입하도록 허용해야 한다.  
> 3\. 임계구역에 들어간 프로세스는 최대한 빠르게 나와야 한다. 그렇지 않으면 다른 프로세스들이 오래 기다려야 한다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 세마포어

이번 포스트에서 상호배제 메커니즘의 한 가지인 세마포어에 대해 알아보자. 회사에서 직원들이 문서작업을 한다. 직원들은 자기 문서의 작업을 마치면 프린터로 작업 결과물을 출력한다. 프린터는 네트워크를 통해 여러 PC에 연결되어 있다. 여기서 공유자원은 프린터가 된다. 직원 A와 직원 B가 우연히 동시에 프린터 출력을 하게 되었다. 그러면 직원 A의 PC와 직원 B의 PC가 프린터를 차지하기 위해서 경쟁조건이 되어버린다. 이러면 프린터의 결과물이 직원 A의 결과물과 직원 B의 결과물이 섞여서 나오기 때문에 쓸모 없어진다. 이런 상황을 막기 위해 팀장님이 아이디어를 냈다. 프린터실을 따로 두어서 거기에 PC와 프린터를 설치한다. 그리고 밖에는 이 방의 열쇠를 관리하는 직원을 따로 두었다. 이제 프린터를 사용하고 싶은 직원 A는 관리자에게 열쇠를 받아서 프린터실로 입장해 프린터를 혼자 사용할 수 있다. 조금 늦게 온 직원 B도 프린터를 사용하고 싶어서 프린터실로 들어가려고 했지만 열쇠관리자는 이미 열쇠를 직원 A에게 준 상태라 직원 B에게 잠시 대기하고 있으라고 한다. 직원 A가 프린터를 다 사용하면 방에서 나오고 열쇠관리자에게 열쇠를 반납한다. 그럼 이제 직원 B가 열쇠를 받고 프린터실로 들어가 프린터를 사용할 수 있다. 지금 설명한 것이 세마포어 메커니즘이다. 단순하고 무식해 보이지만 동기화에서 가장 중요한 개념이다.

이제 조금 전에 봤던 상황을 운영체제에서 쓰이는 용어로 매칭해보자. 프린터를 사용하려는 직원들은 프로세스이다. 프린터는 여러 프로세스들이 같이 쓰고 있는 공유자원이다. 프린터를 쓰기 위해 프로세스가 기다리는 공간은 대기 큐이다. 열쇠 관리자는 운영체제이다. 그리고 열쇠가 바로 세마포어이다. 세마포어는 실제로 정수형 변수이다.

이제 세마포어를 코드로 어떻게 쓰이는지 살펴보자. 이전 포스트의 게임 예시를 들어보겠다.

```c++
int s = 1; // 세마포어 선언
```

먼저 세마포어를 선언해줬다. 공유변수는 health 1개이니 세마포어의 초기 값을 1로 설정한다.

```c++
// 물약 먹는 코드
wait(s); // 열쇠를 요청해서 열쇠를 받고 문을 잠그는 코드

int currentHealth = GetHealth();
health = currentHealth + 50; // 체력 50증가

signal(s); // 방에서 나와 열쇠 관리자에게 열쇠 반납
```

```c++
// 공격 받는 코드
wait(s); // 열쇠를 요청해서 열쇠를 받고 문을 잠그는 코드

int currentHealth = GetHealth();
health = currentHealth - 10; // 체력 10감소

signal(s); // 방에서 나와 열쇠 관리자에게 열쇠 반납
```

그리고 먼저 도착한 물약 먹는 코드를 실행한다. 2번째 줄에 선언한 세마포어 변수 s를 가지고 wait() 함수를 호출한다. wait() 함수는 열쇠를 받을 때까지 기다렸다가 열쇠를 획득하면 방에 들어가 문을 잠그는 함수이다. 지금은 열쇠가 있으니 받아서 바로 문을 잠근다. 이 순간 공격받는 코드로 CPU가 넘어갔다. 그럼 공격받는 코드에서도 wait() 함수를 호출했지만 열쇠가 없어서 열쇠를 받을 때까지 기다린다. 즉, 다음 코드가 실행되지 않고 계속 멈춘다. 시간이 지나서 다시 물약 먹는 코드로 CPU가 넘어가고 signal() 함수가 호출될 때까지 물약 먹는 코드를 실행한다. 물약 먹는 코드가 signal() 함수를 호출해서 열쇠를 반납하면 그제야 공격받는 코드의 wait() 함수가 종료한다. 그럼 시간이 지나서 공격받는 코드로 CPU가 넘어가면 health값을 변경 후에 signal() 함수로 세마포어를 반납한다.

이렇게 세마포어를 이용하면 공유자원에 여러 프로세스가 동시에 접근을 못하기 때문에 동기화 문제가 발생하지 않는다. 예시에서는 열쇠가 1개인 세마포어로 설명했지만 공유자원이 2개면 세마포어 값은 2로 설정해주면 된다. 이렇게 보면 세마포어가 굉장히 좋은 동기화 방법 같지만 단점이 존재한다. wait() 함수와 signal() 함수 순서를 이상하게 호출하거나 연이어서 중복 호출을 해서 잘못 사용할 가능성이 있다. 이것을 해결한 방법이 모니터이다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 모니터

모니터는 저번 포스트에 알아본 세마포어의 단점을 해결한 상호배제 메커니즘이다. 모니터는 따로 운영체제에서 처리하는 것이 아니라 프로그래밍 언어 차원에서 지원하는 방법이다. 대표적으로 java에서 모니터를 지원하는데 예시코드를 살펴보자.

```java
public class Health {
  private int health = 100;

  synchronized void increase(int amount) {
    health += amount;
  }

  synchronized void decrease(int amount) {
    health -= amount;
  }
}
```

변수 health를 선언하고 초기 값을 100으로 설정하였다. 그리고 increase(), decrease() 2개의 메서드를 선언했는데 synchronized 키워드가 붙으면 이 키워드가 붙은 메서드들은 동시에 여러 프로세스에서 실행할 수 없다. 즉 상호배제가 완벽히 이루어진다. 만약 프로세스 A에서 increase() 메서드를 호출하면 프로세스 B는 increase() 뿐만 아니라 synchronized 키워드가 붙은 decrease() 메서드를 실행할 수 없다. 모니터 구현만 완벽하다면 프로그래머는 세마포어처럼 wait() 함수나 signal() 함수를 임계구역에 감싸지 않아도 돼서 편리하고 안전하게 코드를 작성할 수 있다.
