> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 파일과 파일시스템

파일들은 HDD나 SSD와 같은 저장장치에 저장된다. 메모리와 마찬가지로 사용자가 직접 저장하게 된다면 중요한 정보를 훼손할 수 있기 때문에 사용자 운영체제를 통해 요청하면 운영체제가 안전하게 저장해 준다. 운영체제는 파일을 관리하기 위해 파일 관리자를 두었는데 이를 파일시스템이라고 한다. 파일 관리자는 가상 메모리에서 메모리 관리자가 페이지 테이블을 이용해서 가상주소를 물리주소로 변환하는 것처럼 파일 테이블을 이용해서 파일을 관리한다.

> 파일시스템의 기능  
> 1\. 파일과 디렉토리 생성  
> 2\. 파일과 디렉토리 수정/삭제  
> 3\. 파일 접근권한 관리: 요즘 운영체제는 다중 사용자를 지원하기 때문에 파일 보호 필수  
> 4\. 무결성 보장  
> 5\. 백업 및 복구  
> 6\. 파일 암호화

주변장치는 캐릭터 디바이스와 블록 디바이스로 구분한다고 했었는데 HDD와 Flash Memory는 블록 디바이스이다. 파일 시스템은 HDD나 Flash Memory 같은 저장장치에 저장되기 때문에 전송단위가 블록이다. 저장장치의 단위는 블록이지만 사용자는 바이트 단위로 파일에 접근이 가능하기 때문에 이는 파일관리자가 중간에서 관리해 준다.

유닉스 운영체제는 파일에 확장자가 없지만 윈도우 운영체제는 파일마다 확장자가 존재한다. 이 확장자로 파일의 성격을 알 수 있는데 exe파일은 실행파일, jpg, png, bmp 파일은 이미지 파일, mp3, wav 파일은 음악파일, mp4, avi 파일은 동영상 파일로 쉽게 알 수 있다. 이렇게 확장자가 있으면 파일을 더블클릭 했을 때 바로 연결되는 프로그램을 설정할 수 있다. exe파일은 실행파일이기 때문에 운영체제가 바로 프로세스를 만들어 실행하고 이미지 파일은 포토샵이나 그림판, 음악파일은 팟 플레이어나 iTunes가 실행된다.

파일은 헤더와 데이터로 이루어져 있는데 헤더에는 파일의 속성들이 담겨 있다.

> 파일의 속성 종류  
> 1\. 파일 이름  
> 2\. 파일 식별자  
> 3\. 파일 유형  
> 4\. 파일 크기  
> 5\. 시간  
> 6\. 저장위치  
> 7\. 접근권한  
> 8\. 소유자

운영체제는 파일을 관리하기 위해 정보를 보관하는 파일 제어 블록(FCB)을 가지고 있는데 이를 파일 디스크립터라고 부른다. 파일 디스크립터는 파일마다 독립적으로 존재하고 저장장치에 존재하다가 파일이 오픈되면 메모리로 이동한다. 파일 디스크립터는 파일시스템(운영체제)이 관리하고 사용자가 직접 참조는 할 수 없다. 사용자는 파일시스템이 건네준 파일 디스크립터로 파일에 접근이 가능하다.

```c
#include <stdio.h>

int main() {
  int fd;
  fd = open("./test.txt", O_RDONLY);
  close(fd);
}
```

C언어로 예시를 들어보자. 사용자는 파일에 접근하기 위해 open(), close()라는 시스템 콜을 이용한다. 5번째 줄에서 사용자가 open() 함수를 이용해 test.txt라는 파일을 읽기용으로 열기 요청을 하면 운영체제는 해당파일을 찾아 파일 디스크립터를 전달한다. 6번째 줄에도 마찬가지로 사용자가 close()를 이용해 파일 닫기 요청을 하면 운영체제는 해당 파일 디스크립터를 참조해 파일을 안전하게 닫아준다.

파일은 데이터의 집합으로 볼 수 있는데 이 데이터의 집합을 어떻게 구성하느냐에 따라 종류를 나눌 수 있다. 첫 번째는 순차파일구조이다. 순차파일구조는 파일의 내용이 연속적으로 이어진 형태이다. 카세트테이프로 예를 들 수 있다. 카세트테이프에 노래가 100곡이 들어있다면 재생 시 1번부터 100번까지 순차적으로 재생이 된다. 만약 원하는 노래가 있다면 해당 곡까지 테이프를 뒤로 감거나 앞으로 감아서 해당 위치로 가야 한다. 사용자가 파일을 쓰기 위해선 open() 함수를 이용하는데 이때 파일시스템은 파일 디스크립터를 사용자에게 전달한다. 파일 디스크립터는 파일의 맨 앞에 위치해서 사용자가 쓰거나 읽기를 시작하면 처음부터 진행한다. 만약 카세트테이프와 원하는 곡을 찾는 것처럼 파일의 다른 영역으로 가고 싶다면 lseek() 함수를 이용해 파일 디스크립터의 위치를 옮긴다.

```c
#include <stdio.h>

int main() {
  int fd;
  fd = open("./test.txt", O_RDONLY);
  lseek(fd, 10, SEEK_CUR); // 현재 위치에서 10번 앞으로 이동
  close(fd);
}
```

위의 코드에서 5번째 줄은 사용자가 운영체제에게 test.txt라는 파일을 읽기 전용으로 요청한 것이다. 파일을 성공적으로 열었으면 open() 함수는 파일 디스크립터를 전달한다. 6번째 줄에서 open() 함수로 연 파일의 파일 디스크립터를 현재 위치에서 10번 앞으로 이동시킨다. 7번째 줄에서 파일 디스크립터를 이용하여 파일을 안전히 닫는다. 순차파일구조의 장점은 모든 데이터가 순서대로 기록되기 때문에 공간의 낭비가 없고 구조가 단순하다. 단점으로는 특정 지점에 바로 이동이 어려워 데이터를 삽입하거나 삭제하려면 탐색하는데 시간이 많이 걸린다.

두 번째 구조인 직접파일구조를 알아보자. 직접파일구조는 저장하려는 데이터를 해시함수를 통해 저장위치를 결정하는 파일구조이다. 이 구조는 자료구조에서 해시테이블이라는 이름으로 불리는 방식이고 요즘 많이 쓰이는 데이터 포맷인 json도 이 방식이다. 사람 이름으로 데이터를 저장한다고 가정하자. 사람의 성씨를 기준으로 주소를 변환하는 해시함수가 있다고 하자. 그럼 사람의 이름을 입력으로 주면 해당 성씨에 해당하는 성씨에 해당하는 공간에 데이터가 저장된다. 만약 "김철수"라는 사람을 저장하려 하면 해시함수는 김철수를 입력받고 성씨를 구분한다. 성이 김 씨이니까 주소 "김"에 저장한다. 직접파일구조의 장점은 해시함수를 이용하기 때문에 데이터 접근이 굉장히 빠르다. 단점으로는 해시함수의 선정이 굉장히 중요하기 때문에 해시함수를 잘 골라야 하는 점과 저장공간이 낭비될 수 있다는 점이 있다.

세 번째 구조인 인덱스 파일구조에 대해 알아보자. 인덱스 파일구조는 음악재생 프로그램에서 재생목록을 예로 들 수 있다. 재생목록을 그냥 재생시키면 처음부터 마지막까지 순차적으로 재생된다. 하지만 원하는 곡이 있다면 해당 곡을 클릭하면 재생되는데 이 같은 구조를 인덱스 파일구조라고 부른다. 예시로 재생목록을 통하여 인덱스 파일구조를 좀 더 살펴보자. 재생목록은 전부 순차 데이터로 저장된다. 보통 재생을 누르면 처음부터 마지막 순으로 순차 재생되는데 사용자가 77번 노래를 듣고 싶어서 노래를 재생시키면 인덱스 테이블의 77번에 접근해 블록 번호를 알아내고 순차 데이터의 해당 블록번호로 이동해 77번 음악을 재생시키는 구조이다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 디렉터리

파일을 하나의 공간에 보관하면 파일이 많아지면서 굉장히 복잡할 것이다. 그래서 관련 있는 파일을 모아 둘 수 있도록 디렉터리가 등장하였다. 디렉토리는 1개 이상의 파일을 가질 수 있고 자식 디렉토리도 가질 수 있다. 디렉토리는 여러 층으로 구성되는데 푀상위에 있는 디렉토리를 루트 디렉토리라 부른다. 유닉스나 리눅스의 경우 루트 디렉토리를 "/"로 표시하고 디렉토리와 디렉토리 구분을 위해서도 "/"를 사용한다. 윈도우의 경우 루트 디렉토리는 파티션 이름으로 사용하는데 보통 "C:"로 표시한다. 윈도우는 디렉토리와 디렉토리 구분을 "\\"로 한다.

디렉터리라고 해서 파일과 다른 구조가 아니다. 디렉토리도 파일이다. 단지 일반 파일에는 데이터가 저장되고 디렉터리에는 파일정보가 저장되어있다. 또한 디렉토리의 디렉토리 헤더는 디렉토리 정보가 시작되는 위치를 가르킨다. 디렉토리에 점 1개와 점 2개가 있는데 이는 현재 디렉터리와 상위 디렉터리를 나타낸다. 점 1개는 현재 디렉토리를 가르키고 점 2개는 상위 디렉토리를 가리킨다. 루트 디렉터리의 경우 상위 디렉토리가 없기 때문에 점 2개도 자기 자신을 가리킨다.

디렉터리의 구조에 대해 알아보자. 초기 파일시스템의 디렉터리는 단순한 구조였다. 루트 디렉토리에만 디렉토리가 존재할 수 있었고 다른 디렉터리에서는 하위 디렉토리를 만들 수 없었다. 하지만 파일이 많이지면서 불편함이 생거 다단계 디렉토리 구조가 등장하였다. 다단계 디렉토리는 어떠한 디렉토리에서도 하위 디렉토리를 만들 수 있는 트리구조이다. 우리가 쓰는 운영체제는 트리구조에서 순환이 생기는데 그 이유는 바로가기 기능이 있기 때문이다. 윈도우는 바로가기 아이콘을 만들어 특정 디렉토리에서 다른 디렉터리도 바로 이동하는 기능이 있기 때문에 순환이 있는 트리구조이다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 파일과 디스크

파일시스템은 메모리와 비슷하다. 페이징과 같이 전체 디스크 공간을 일정한 크기로 나누고 그 공간에 주소를 할당해 관리한다. 일정한 크기로 나눈 공간을 메모리에선 페이지라고 부르고 파일시스템에선 블록이라고 부른다. 한 블록의 크기는 1~8KB 정도다. 파일시스템은 파일정보를 파일 테이블로 관리하는데 여기엔 파일이 시작하는 블록의 위치정보가 담겨있다.

하나의 파일은 여러개의 블록으로 이루어져 있는데 이 블록들은 어떻게 연결하는지에 따라 "연속할당"과 "불연속 할당"으로 나눌 수 있다. 연속할당은 파일을 구성하는 블록들을 디스크에 연속적으로 저장하는 방식이다. 파일의 시작 블록만 알면 파일의 전체를 찾을 수 있다. 이 방식은 메모리에서 세그멘테이션 기법처럼 외부 단편화가 발생하기 때문에 실제로 사용되지 않는 방식이다. 불연속 할당은 디스크에 비어있는 공간에 데이터를 분산해 저장하는 방식이다. 이 분산된 블록은 파일 시스템이 관리한다. 불연속 방식으로는 "연결할당"과 "인덱스 할당"이 있다. 먼저 불연속 할당의 "연결할당"을 알아보자. 자료구조에는 연결리스트라는 것이 있다. 연결리스트는 각 노드가 데이터와 포인터를 가지고 있다. 데이터는 말 그대로 해당 노드가 저장하고 있는 데이터이고 포인터는 이전 노드와 다음 노드의 주소를 가리킨다. 이렇게 구성하면 하나의 노드의 포인터를 이용해 다른 노드로 이동하여 모든 노드를 순환할 수 있다. 연결할당은 파일에 속한 데이터를 연결리스트로 관리한다. 파일 테이블에는 시작 블록에 대한 정보만 저장하고 나머지는 연결리스트를 이용해 다른 블록에 접근하는 방식이다. 예를 들어 C라는 파일을 참조한다고 하면 파일 테이블을 참조해 C에 해당하는 몇 번 블록인지를 확인한다. 예를 들어 1번 블록이라고 한다면 파일 할당 테이블(FAT)의 첫 번째 행에 있는 블록을 접근한다. 1번 블록에 있는 데이터를 가져오고 1번이 가리키고 있는 다음 블록을 다시 참조하여 데이터를 가져온다. 이런 식으로 NULL을 만날 때까지 데이터를 참조하면 모든 데이터를 얻을 수 있다. 다음으로 불연속 할당의 "인덱스 할당"을 알아보자. 인덱스 할당 방식은 테이블의 블록 포인터가 데이터 블록에 직접 연결하는 것이 아니라 데이터들의 인덱스를 가지고 있는 인덱스 블록을 연결한다. 접근하려는 파일의 데이터가 0, 3, 4번이라고 가정하자. 그럼 이 파일을 구성하는 0, 3, 4번을 저장한 인덱스 블록이 있고 이 블록을 파일 테이블의 블록 포인터가 가리키게 된다. 인덱스 블록에 있는 0, 3, 4번을 참조하면 데이터를 모두 찾을 수 있다. 인덱스 할당은 데이터가 많아서 테이블이 꽉 찬 경우 인덱스 블록을 더 만들어 연결하기 때문에 테이블을 확장할 수 있다. 덕분에 파일의 크기가 작다면 데이터를 바로 참조하는 블록 포인터를 이용하고 파일의 크기가 크다면 간접 포인터를 이용해 많은 데이터에 접근할 수 있다. 만약 더 큰 데이터가 필요하다면 이중 간접 포인터, 삼중 간접 포인터를 이용할 수 있다. 이 방식은 i-node라는 이름으로 유닉스와 리눅스에서 많이 사용되고 있다.

디스크는 일정한 크기의 블록으로 나뉘고 블록의 크기는 1~8KB정도다. 디스크를 1KB 정도로 나누면 낭비되는 공간을 줄일 수 있지만 관리해야 할 블록의 수도 많아진다. 반대로 8KB로 나누면 관리해야 하는 블록의 수는 적지만 내부 단편화로 낭비되는 공간이 많아진다. 어느 게임의 설정파일이 있다 하자. 내 컴퓨터에서 한 블록의 크기가 4096byte라고 하자. 이 파일의 크기가 약 12KB라 하면 4096byte 세 블록으로는 크기가 부족하다. 그래서 네 블록이 쓰이고 디스크 할당은 약 16KB가 할당된다. 결과적으로 3928byte만큼 내부단편화가 발생한다.

디스크에 파일을 저장할 때마다 빈 공간을 찾으려 모든 공간을 뒤지는 방식은 비효율적이다. 파일 시스템은 효율적인 관리를 위헤 빈 공간을 모아 둔 free block list를 가지고 있다. 만약 특정 파일을 삭제한다면 파일 시스템은 모든 정보를 지우는 것이 아니라 파일 테이블의 헤더를 삭제하고 free block list에 추가한다. 만약 파일을 지운다고 가정한다면 파일 테이블에서 해당 파일의 헤더를 지워주고 사용했던 블록을 free block list에 넣어준다. 이렇게 처리하면 사용자는 파일이 삭제된 것처럼 느껴지는 데 사용했던 블록의 데이터는 그대로 남아있기 때문에 범죄를 저질러서 증거를 인멸해도 포렌식을 통해 데이터를 복구할 수 있다.
