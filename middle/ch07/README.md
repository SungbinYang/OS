> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 가상메모리 개요

컴퓨터마다 실제 메모리의 크기가 다르다. 만약 운영체제나 프로세스가 4GB 메모리에서 동작하도록 만들어졌다면 이보다 작은 메모리를 가진 컴퓨터에서는 실행을 할 수 없다. 가상메모리에는 이런 문제를 완벽히 해결하였다. 프로세스는 운영체제의 영역이 어디 있는지 혹은 물리 메모리의 크기가 얼마나 큰지 몰라도 된다. 즉, 개발자는 물리 메모리의 크기와 프로세스가 메모리 어느 위치에 올라가는지 신경 쓰지 않고 0x0번지에서 시작된다고 생각하고 개발을 하면 된다. 프로세스는 메모리 관리자를 통해서 메모리에 접근이 가능하다. 프로세스 입장에서는 물리 메모리에 직접 접근할 일이 없고 메모리 관리자에게 요청만 하면 된다. 메모리 관리자는 프로세스의 요청이 있으면 그에 맞는 물리 메모리로 연결시켜 준다. 가상 메모리의 크기는 이론적으로 무한대지만 실제로는 물리 메모리의 크기와 CPU의 bit수로 결정된다. 만약 32bit CPU인 경우 표현할 수 있는 주소 값은 2^32으로 대략 4GB 정도 되고 가상메모리 크기도 4GB이다.

32bit CPU의 경우 최대 메모리 크기가 4GB라고 했는데 운영체제를 포함해서 수많은 프로세스들은 어떻게 실행할까? 4GB를 차지하는 프로세스 5개와 운영체제를 실행한다고 가정하자. 그럼 운영체제를 제외하고도 적어도 20GB가 필요한데 4GB로는 턱없이 부족하다. 이럴 때 가상메모리 시스템은 물리 메모리 내용의 일부를 HDD에 있는 스왑영역으로 옮기고 처리가 필요할 때 물리 메모리로 가져와 실행시키기 때문에 운영체제와 프로세스 5개를 전부 실행이 가능하다.

메모리 관리자는 물리 메모리와 스왑영역을 합쳐서 프로세스가 사용하는 가상주소를 물리주소로 변환하는데 이것을 동적주소변환이라고 한다. 이 가상주소는 메모리나 스왑영역에 저장한다. 동적주소변환을 거치면 프로세스는 마음대로 사용자 데이터를 물리 메모리에 배치할 수 있다. 메모리 관리자는 "물리 메모리를 어떻게 나눌지", "프로세스를 어디다 배치할지", "부족한 물리 메모리는 어떻게 처리할지"와 같은 문제를 처리해야 하기 때문에 복잡한 과정을 거친다. 실제 물리주소 0x0번지는 운영체제 영역이므로 프로세스가 사용하지 못한다. 가상메모리 시스템에서는 운영체제 영역을 제외한 나머지 영역을 일정한 크기로 나우어서 프로세스에게 할당하는데 할당하는 방식은 메모리 분할방식과 마찬기지로 가변분할방식과 고정분할방식으로 나뉜다.

가상메모리 시스템에서 가변분할방식을 이용한 세그멘테이션, 고정분할방식을 이용한 페이징이라는 것이 있다. 세그멘테이션에는 외부단편화와 같은 단점이 있고 페이징에서는 내부단편화와 같은 단점이 있기 때문에 이 단점을 보완한 세그멘테이션-페이징 혼용기법을 사용한다. 가상메모리 시스템에서 가상주소는 메모리나 스왑영역 한 곳중에 위치하는데 메모리 관리자는 가상주소와 물리주소를 1:1 매핑 테이블로 관리한다. 매핑 테이블을 보면 프로세스가 세그먼트 n에 위치하는지 혹은 스왑영역에 저장하는지 알 수 있다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 세그멘테이션(배치정책)

가변분할 방식을 이용한 세그멘테이션 기법을 보자. 세그멘테이션에서 프로그램은 함수나 모듈등으로 세그먼트를 구성한다. 프로세스 입장에서 메모리를 살펴보면 메인코드가 있는 세그먼트, 전역 데이터들이 있는 세그먼트, 힙영역이 있는 세그먼트, 스택영역이 있는 세그먼트 등이 있다. 각 세그먼트들은 서로 인접할 필요가 없다. 반면 프로세스 입장에서는 우리가 앞서 봤던 것처럼 코드영역, 데이터영역, 힙영역, 스택영역을 서로 인접한 것처럼 바라본다.

시용자와 프로세스, CPU가 바라보는 주소는 논리주소라고 한다. 실제 물리주소 변환은 중간에 메모리 관리자(MMU)가 해준다. 그럼 메모리 관리자는 어떻게 논리주소를 물리주소로 변환할까? 메모리 관리자는 세그멘테이션 테이블이라는 것을 가지고 있다. 세그멘테이션 테이블에는 Base Address와 Bound Address정보가 저장되어 있고 이걸 이용하여 물리 메모리 주소를 계산한다. CPU에서 논리주소를 전달해주면 메모리 관리자는 이 논리주소가 몇 번 세그먼트인지 알아낸다. 그리고 메모리 관리자 내에 Segment Table Base Register를 이용해서 물리 메모리 내에 있는 세그멘테이션 테이블을 찾고 세그먼트 번호를 인덱스로 Base Address와 Bound Address를 찾는다.

> 운영체제는 컨텍스트 스위칭을 할 때마다 메모리 관리자 내에 Segment Table Base Register를 해당 프로세스의 것으로 값을 바꿔줘야 한다. 컨텍스트 스위칭은 이런 작업까지 하기 때문에 굉장히 무거운 동작이다.

Bound Address는 세그먼트의 크기를 나타낸다. 메모리 관리자는 CPU에서 받은 논리주소와 Bound Address의 크기를 비교한다. 만약 논리주소가 Bound Address보다 작다면 논리주소와 Base Address를 더하여 물리주소를 구하고 논리주소가 Bound Address보다 크다면 메모리를 침범했다고 생각하고 에러를 발생시킨다.

그럼 예시로 논리주소를 물리주소로 변환하는 걸 두가지만 살펴보자. 첫 번째로 CPU에서 세그먼트 1번이 0x632번지로 접근한다고 가정하자. 메모리 관리자는 CPU 요청을 받고 세그먼트 1번인 것을 알아낸다. 그리고 메모리 관리자 내에 있는 Segment Table Base Register를 이용해서 세그멘테이션 테이블을 찾는다. 세그멘테이션 테이블을 찾은 다음 세그먼트 1번이 위치한 1번 인덱스를 참조한다. 논리주소 632와 Bound Address를 비교하니 만약 논리주소가 더 작다면 이 632와 Base Address(ex. 5000)를 더하여 5632가 나온다. 최종적으로 논리주소 0x632번지는 물리주소 0x5632번지로 성공적으로 변환하였다.

두 번째 예시로 세그먼트 3번이 0x750번지로 접근한다고 가정하자. 메모리 관리자는 CPU의 요청을 받고 세그먼트 3번인 것을 알아낸다. 그리고 Segment Table Base Register를 이용해 세그멘테이션 테이블을 찾아 3번 인덱스를 참조한다. 논리주소 750과 Bound Address를 비교하니 논리주소가 더 크다고 하자. 그러면 메모리 관리자는 메모리를 침범했다고 판단하고 인터럽트를 발생시켜 프로세스를 종료시킨다.

세그멘테이션의 장접은 메모리를 가변적으로 분할할 수 있고 코드영역, 데이터영역, 스택영역, 힙영역을 모두 처리할 수 있기 때문에 공유와 각 영역에 대한 메모리 접근보호가 편리하고 관리가 쉽다. 하지만 단점으로 가변분할방식의 단점인 "외부 단편화"가 발생한다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 페이징

이번 포스트에서 고정분할방식을 이용한 페이징에 대해 알아보자. 세그멘테이션 기법은 외부단편화 문제가 있기 때문에 이를 해결하기 위해 고안되었다.(조각모음은 오버헤드가 너무 큼) 페이징은 메모리를 할당할 때 정해진 크기의 페이지로 나눈다. 모든 페이지는 크기가 같기 때문에 관리가 굉장히 쉽다. 또한 일정한 크기로 나눴기 때문에 외부단편화 현상이 일어나지 않는다. 대신 내부단편화가 발생한다.

논리주소공간과 물리주소공간이 있다고 하자. 논리주소공간은 사용자와 프로세스가 바라보는 주소공간이고 물리주소공간은 실제 메모리에서 사용되는 주소공간이다. 페이징에서 논리주소공간은 일정한 크기로 균일하게 나눈다. 이것을 페이지라고 부른다. 물리주소공간도 페이지의 크기와 동일하게 나누는데 이것을 프레임이라고 부른다.

그럼 페이징의 주소변환을 어떻게 하는지 알아보자. 세그멘테이션과 마찬가지로 메모리 관리자는 테이블을 가지고 있는데 이를 페이지 테이블이라고 부른다. CPU에서 논리주소를 전달해 주면 메모리 관리자는 이 논리주소가 몇 번 페이지인지 오프셋은 얼마인지 알아낸다. 그리고 메모리 관리자 내에 Page Table Base Register를 이용해서 물리 메모리에 있는 페이지 테이블을 찾고 페이지 번호를 인덱스로 프레임 번호를 알아내고 오프셋을 이용해 물리주소 변환을 한다. 페이지 테이블에 invalid라고 표시되어 있으면 스왑영역, HDD에 저장되었다는 의미이다.

> 세그멘테이션과 마찬가지로 Page Table Base Register는 운영체제가 컨텍스트 스위칭을 할 때마다 해당 프로세스의 것으로 업데이트를 해줘야 한다.

그럼 32bit CPU가 어떻게 주소변환을 하는지 알아보자. 32bit CPU에서 가상 메모리 크기는 약 4GB이다. 이 4GB의 가상메모리를 크기가 2^24, 약 16MB인 페이지로 나눠보자. 그럼 32bit 중에 24bit는 페이지의 크기를 나타내고 나머지 8bit는 페이지 번호를 나타낸다. 페이지 번호는 2^8이니까 총 256개 페이지가 존재하게 된다. 이렇게 나눴으면 4GB 메모리가 16MB의 페이지 256개로 나뉘게 된 것이다. 그러면 페이지 0 은 0~16777216번지, 페이지 1은 16777217~33554432번지, 페이지 255는 4278190081~4294967296번지로 구성되어 있다. 이제 물리주소의 프레임도 가상주소의 페이지의 크기와 동일하게 16MB로 나누자. 물리주소(2GB)는 프레임 128개로 구성된다. 이렇게 예시를 든 이유는 물리주소의 크기가 가상주소의 크기보다 작아도 문제가 없다는 것을 보여주기 위해서 이렇게 예시를 든 것이다. 부족한 물리메모리는 스왑처리를 하기 때문에 괜찮다. 메모리 관리자 내에 페이지 테이블은 1차원 배열로 구성되어 있는데 페이지 번호가 배열의 인덱스가 된다. 해당 인덱스로 가면 프레임을 얻을 수 있다. 이제 여기서 CPU가 논리주소 0x1000번지에 접근하다고 가정하자. 논리주소 0x1000번지의 물리주소를 구해보자. 그럼 일단 페이지 번호와 오프셋값을 구해야 한다. 구하는 공식은 아래와 같다.

> 페이지 번호: 논리주소 / 페이지 크기  
> 오프셋: 논리주소 % 페이지 크기

그러면 위의 공식을 적용하면 페이지 번호는 0이고 오프셋은 1000이 나온다. 그러면 페이지 번호와 오프셋을 구했으니 페이지 넘버를 페이지 테이블 인덱스로 참조한다. 0번 인덱스의 프레임 번호가 3이라고 한다면 프레임 3번 위치에 오프셋 1000만큼 더하면 물리주소 변환이 완료된다. 두 번째 예시를 들어보자. CPU가 논리주소 0x31554432번지에 접근한다고 가정하자. 그럼 페이지 번호를 구해야 한다. 공식에 대입하면 페이지 번호는 1이 나온다. 이제 오프셋을 구해보자. 오프셋을 구하면 1477216이 나온다. 페이지 넘버와 오프셋을 구했으니 페이지 번호를 페이지 테이블의 인덱스로 참조한다. 즉, 1번 인덱스를 참조하여 프레임을 구한다. 프레임이 1이라고 가정한다면 이 프레임 1 위치에서 1477216을 더해주면 물리주소 변환이 완료된다.

여기까지 보면 세그멘테이션과 페이징은 굉장히 비슷해 보인다. 이 둘의 차이는 무엇일까? 바로 페이지의 크기이다. 세그멘테이션은 프로세스마다 크기가 달라 Bound Address를 가지고 있지만 페이징은 모든 페이지의 크기가 동일해서 크기를 표현하는 Bound Address는 필요하지 않다. 페이징은 이러한 특징 때문에 외부단편화는 발생하지 않지만 내부단편화는 발생한다. 정해진 크기의 페이징보다 프로세스의 정보가 작으면 그만큼 공간이 낭비되는데 이를 내부단편화라고 한다. 하지만 세그멘테이션의 단점과 비교하면 많은 공간이 낭비되는 것이 아니라 심각하게 생각을 안 해도 괜찮다. 또 다른 차이는 무엇일까? 이것도 페이지의 크기 때문에 생긴 차이인데 세그멘테이션은 논리적인 영역별로 세그먼트를 나눈다. 세그먼트마다 크기를 다르게 나눌 수 있으니 코드영역, 데이터영역, 스택영역, 힙영역을 나눌 수 있다. 하지만 페이징은 페이지의 크기가 고정되어 있어서 논리적인 영역별로 나누는 것이 아니라 페이지로 나누기 때문에 논리적인 영역을 나눌 수 없다. 그래서 특정 영역만 딱 떼어내서 공유하거나 권한을 부여하기 힘들다. 또한 페이징의 가장 신경 써야 하는 것은 페이지 테이블의 크기이다. 각 프로세스마다 페이지 테이블을 가지고 있는데 프로세스가 많아질수록 페이지 테이블도 많아지기 때문에 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어든다. 실제로 메모리 관리자가 참조하는 페이지 테이블도 물리 메모리의 운영체제 영역에 저장되어 있기 때문에 페이지 테이블 크기가 너무 크면 사용자 영역이 부족하다. 이 때문에 페이지 테이블 크기를 적절히 유지하는 게 중요하다.
