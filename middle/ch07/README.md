> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 가상메모리 개요

컴퓨터마다 실제 메모리의 크기가 다르다. 만약 운영체제나 프로세스가 4GB 메모리에서 동작하도록 만들어졌다면 이보다 작은 메모리를 가진 컴퓨터에서는 실행을 할 수 없다. 가상메모리에는 이런 문제를 완벽히 해결하였다. 프로세스는 운영체제의 영역이 어디 있는지 혹은 물리 메모리의 크기가 얼마나 큰지 몰라도 된다. 즉, 개발자는 물리 메모리의 크기와 프로세스가 메모리 어느 위치에 올라가는지 신경 쓰지 않고 0x0번지에서 시작된다고 생각하고 개발을 하면 된다. 프로세스는 메모리 관리자를 통해서 메모리에 접근이 가능하다. 프로세스 입장에서는 물리 메모리에 직접 접근할 일이 없고 메모리 관리자에게 요청만 하면 된다. 메모리 관리자는 프로세스의 요청이 있으면 그에 맞는 물리 메모리로 연결시켜 준다. 가상 메모리의 크기는 이론적으로 무한대지만 실제로는 물리 메모리의 크기와 CPU의 bit수로 결정된다. 만약 32bit CPU인 경우 표현할 수 있는 주소 값은 2^32으로 대략 4GB 정도 되고 가상메모리 크기도 4GB이다.

32bit CPU의 경우 최대 메모리 크기가 4GB라고 했는데 운영체제를 포함해서 수많은 프로세스들은 어떻게 실행할까? 4GB를 차지하는 프로세스 5개와 운영체제를 실행한다고 가정하자. 그럼 운영체제를 제외하고도 적어도 20GB가 필요한데 4GB로는 턱없이 부족하다. 이럴 때 가상메모리 시스템은 물리 메모리 내용의 일부를 HDD에 있는 스왑영역으로 옮기고 처리가 필요할 때 물리 메모리로 가져와 실행시키기 때문에 운영체제와 프로세스 5개를 전부 실행이 가능하다.

메모리 관리자는 물리 메모리와 스왑영역을 합쳐서 프로세스가 사용하는 가상주소를 물리주소로 변환하는데 이것을 동적주소변환이라고 한다. 이 가상주소는 메모리나 스왑영역에 저장한다. 동적주소변환을 거치면 프로세스는 마음대로 사용자 데이터를 물리 메모리에 배치할 수 있다. 메모리 관리자는 "물리 메모리를 어떻게 나눌지", "프로세스를 어디다 배치할지", "부족한 물리 메모리는 어떻게 처리할지"와 같은 문제를 처리해야 하기 때문에 복잡한 과정을 거친다. 실제 물리주소 0x0번지는 운영체제 영역이므로 프로세스가 사용하지 못한다. 가상메모리 시스템에서는 운영체제 영역을 제외한 나머지 영역을 일정한 크기로 나우어서 프로세스에게 할당하는데 할당하는 방식은 메모리 분할방식과 마찬기지로 가변분할방식과 고정분할방식으로 나뉜다.

가상메모리 시스템에서 가변분할방식을 이용한 세그멘테이션, 고정분할방식을 이용한 페이징이라는 것이 있다. 세그멘테이션에는 외부단편화와 같은 단점이 있고 페이징에서는 내부단편화와 같은 단점이 있기 때문에 이 단점을 보완한 세그멘테이션-페이징 혼용기법을 사용한다. 가상메모리 시스템에서 가상주소는 메모리나 스왑영역 한 곳중에 위치하는데 메모리 관리자는 가상주소와 물리주소를 1:1 매핑 테이블로 관리한다. 매핑 테이블을 보면 프로세스가 세그먼트 n에 위치하는지 혹은 스왑영역에 저장하는지 알 수 있다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 세그멘테이션(배치정책)

가변분할 방식을 이용한 세그멘테이션 기법을 보자. 세그멘테이션에서 프로그램은 함수나 모듈등으로 세그먼트를 구성한다. 프로세스 입장에서 메모리를 살펴보면 메인코드가 있는 세그먼트, 전역 데이터들이 있는 세그먼트, 힙영역이 있는 세그먼트, 스택영역이 있는 세그먼트 등이 있다. 각 세그먼트들은 서로 인접할 필요가 없다. 반면 프로세스 입장에서는 우리가 앞서 봤던 것처럼 코드영역, 데이터영역, 힙영역, 스택영역을 서로 인접한 것처럼 바라본다.

시용자와 프로세스, CPU가 바라보는 주소는 논리주소라고 한다. 실제 물리주소 변환은 중간에 메모리 관리자(MMU)가 해준다. 그럼 메모리 관리자는 어떻게 논리주소를 물리주소로 변환할까? 메모리 관리자는 세그멘테이션 테이블이라는 것을 가지고 있다. 세그멘테이션 테이블에는 Base Address와 Bound Address정보가 저장되어 있고 이걸 이용하여 물리 메모리 주소를 계산한다. CPU에서 논리주소를 전달해주면 메모리 관리자는 이 논리주소가 몇 번 세그먼트인지 알아낸다. 그리고 메모리 관리자 내에 Segment Table Base Register를 이용해서 물리 메모리 내에 있는 세그멘테이션 테이블을 찾고 세그먼트 번호를 인덱스로 Base Address와 Bound Address를 찾는다.

> 운영체제는 컨텍스트 스위칭을 할 때마다 메모리 관리자 내에 Segment Table Base Register를 해당 프로세스의 것으로 값을 바꿔줘야 한다. 컨텍스트 스위칭은 이런 작업까지 하기 때문에 굉장히 무거운 동작이다.

Bound Address는 세그먼트의 크기를 나타낸다. 메모리 관리자는 CPU에서 받은 논리주소와 Bound Address의 크기를 비교한다. 만약 논리주소가 Bound Address보다 작다면 논리주소와 Base Address를 더하여 물리주소를 구하고 논리주소가 Bound Address보다 크다면 메모리를 침범했다고 생각하고 에러를 발생시킨다.

그럼 예시로 논리주소를 물리주소로 변환하는 걸 두가지만 살펴보자. 첫 번째로 CPU에서 세그먼트 1번이 0x632번지로 접근한다고 가정하자. 메모리 관리자는 CPU 요청을 받고 세그먼트 1번인 것을 알아낸다. 그리고 메모리 관리자 내에 있는 Segment Table Base Register를 이용해서 세그멘테이션 테이블을 찾는다. 세그멘테이션 테이블을 찾은 다음 세그먼트 1번이 위치한 1번 인덱스를 참조한다. 논리주소 632와 Bound Address를 비교하니 만약 논리주소가 더 작다면 이 632와 Base Address(ex. 5000)를 더하여 5632가 나온다. 최종적으로 논리주소 0x632번지는 물리주소 0x5632번지로 성공적으로 변환하였다.

두 번째 예시로 세그먼트 3번이 0x750번지로 접근한다고 가정하자. 메모리 관리자는 CPU의 요청을 받고 세그먼트 3번인 것을 알아낸다. 그리고 Segment Table Base Register를 이용해 세그멘테이션 테이블을 찾아 3번 인덱스를 참조한다. 논리주소 750과 Bound Address를 비교하니 논리주소가 더 크다고 하자. 그러면 메모리 관리자는 메모리를 침범했다고 판단하고 인터럽트를 발생시켜 프로세스를 종료시킨다.

세그멘테이션의 장접은 메모리를 가변적으로 분할할 수 있고 코드영역, 데이터영역, 스택영역, 힙영역을 모두 처리할 수 있기 때문에 공유와 각 영역에 대한 메모리 접근보호가 편리하고 관리가 쉽다. 하지만 단점으로 가변분할방식의 단점인 "외부 단편화"가 발생한다.
