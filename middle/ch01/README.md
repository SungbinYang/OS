> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 프로그램과 프로세스

프로그램이란, 하드디스크등과 같은 저장장치에 저장된 명령문의 집합체, 애플리케이션이라고 불리며 Windows 운영체제에서는 exe파일의 모습을 띤다. 프로세스는 쉽게 말해 실행 중인 프로그램을 의미한다. 실행 중인 프로그램이란 하드디스크에 저장된 프로그램이 메모리에 올라왔을 때 실행 중인 프로그램, 프로세스라고 불린다. 프로그램은 컴퓨터 관점에서 저장장치만 사용하는 수동적인 존재인 반면에 프로세스는 메모리도 사용하고 CPU 스케줄링 알고리즘에 따라 CPU도 사용하고 필요에 따라 I/O를 하기 때문에 능동적인 존재이다.

### 프로세스 구조

프로세스는 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 이루어 진다. 코드 영역은 자신을 실행하는 코드가 저장되어 있고, 데이터 영역은 전역변수와 static 변수가 저장되어 있다. 스택 영역은 지역변수와 함수를 호출했을 때 필요정보(함수 호출 시 매개변수와 돌아갈 주소)를 저장한다. 힙 영역은 개발자가 동적으로 메모리를 할당하는 데 쓰인다. 즉, 개발자가 런타임시 할당할 수 있는 메모리 공간을 의미한다. C언어에서 malloc(힙 영역에 메모리 공간 할당), free(할당된 메모리 공간 해제) 함수로 힙 영역의 자원을 할당 혹은 해제할 수 있다.

### 코드가 메모리에 올라가 프로세스가 되는 과정

```c
#include <stdio.h>

void main() {
  int a = 5;
  int b = 7;
  int result = a + b;
}
```

이제 위의 코드의 프로그램이 어떻게 프로세스가 되는지 알아보자. 위의 코드는 C언어로 작성되어있다. C언어는 컴파일 언어이기 때문에 컴파일이 되어야 실행 가능함으로 컴파일을 해줘야 한다. 컴파일 과정은 먼저 전처리기를 거쳐서 메크로로 정의된 숫자를 치환시켜 주고 필요한 파일들을 불러온다. 전처리기를 거치면 파일의 확장자는. i가 된다. 그다음 컴파일러가 컴파일을 해준다. 컴파일을 마치면 C언어는 저수준의 어셈블리어로 변경된다. 어셈블리어는 명령어가 기계어랑 1:1 매칭이 되기 때문에 기계어랑 가장 가까운 언어이다. 이때 파일의 확장자는. s다. 이제 어셈블러가 어셈블리어를 기계어로 바꿔준다. 그럼 파일은 0과 1로 이루어진 기계어로 구성되고 파일의 확장자는. o가 된다. 마지막으로 링커가 링킹을 해준다. 여러 가지 라이브러리나 다른 소스코드들을 연결해 준다. 그러면 파일은 이제 exe파일이 되고 이 파일을 더블 클릭했을 때 메모리에 올라가고 이 프로그램은 프로세스가 된다. 이 프로세스는 운영체제에 의해 관리되며 운영체제의 전략에 따라 프로세스가 실행되는데 이를 CPU관점으로 봐보자. 위의 코드의 예시를 들어서 설명해 보겠다.

CPU는 0과 1과 같은 기계어를 실행하는데 CPU내에 제어장치가 숫자 5, 7을 저장한다. 이 메모리에 저장된 값을 각 레지스터로 가져온다. 레지스터의 값을 ALU가 실행 후 결과 값을 기존 레지스터의 한 곳에 저장을 한다. 이제 제어장치가 이 값을 메모리로 전달한다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 멀티프로그래밍과 멀티프로세싱

이번에는 유니프로그래밍과 멀티프로그래밍, 멀티프로세싱에 대해 알아보자. **유니프로그래밍**은 메모리에 오직 1개의 프로세스가 올라오는 것을 말하고 반대로 **멀티프로그래밍**은 메모리에 여러 개의 프로세스가 올라온 것을 말한다. **멀티프로세싱**이란 유니프로그래밍과 멀티프로그래밍을 메모리 관점으로 정의를 한 것이라면 멀티프로세싱은 CPU관점으로 정의한 것이다. 멀티프로세싱은 CPU가 여러 개의 프로세스를 처리하는 것을 말한다.

오늘날 운영체제는 멀티프로그래밍과 멀티프로세싱 2개가 공존한다. 메모리에는 여러개의 프로세스가 올라오는 멀티프로그래밍이 있고 **시분할 처리**로 CPU가 각각의 프로세스를 짧은 시간동안 교대로 실행하는 멀티 프로세싱이 있다. 과거에는 메모리 크기가 작아서 멀티프로그래밍은 불가능했다. 이때는 유니프로그래밍을 하면서 멀티프로세싱을 이용하였다. 메모리에 프로세스를 올려 CPU를 처리하고 이 프로세스를 다른 저장장치에 저장을 하고 다른 저장장치에 있던 프로세스를 메모리에 올려 CPU를 처리하는 멀티프로세싱 기법을 이용했는데, 이 때 메모리에 있는 데이터를 다른 저장장치로 보내고 다른 저장장치에 메모리를 올리는 이 과정을 **스와핑**이라고 한다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## PCB

프로그램이 메모리에 올라가 실행 중인 상태를 프로세스라고 말한다. 운영체제는 여러 개의 프로세스를 전부 관리하고 공평하게 실행되어야만 한다. 프로세스가 만들어지면 운영체제는 해당 프로세스의 정보를 가지고 있는 PCB를 만들고 저장한다.

> PCB들은 연결리스트라는 자료구조로 저장된다.

> 연결리스트는 각각의 데이터가 다음 데이터를 연결하는 구조로 되어 있는 자료구조이다.

운영체제는 프러세스가 종료되면 연결리스트에서 해당 프로세스의 PCB를 제거한다.

### PCB 구조

- 포인터: 부모와 자식 프로세스에 대한 포인터와 할당된 자원에 대한 포인터, 프로세스의 한 상태에서 다른 상태로 전환할 때 저장하는 포인터를 가진다.(효율적인 접근을 위해 포인터 사용)
- 프로세스 상태: 현재 프로세스의 5가지 상태로는 생성, 준비, 실행, 대기, 완료가 있다.
- 프로세스 ID(PID): 프로세스를 식별하기 위한 양의 정수값이 저장
- 프로그램 카운터(PC): 다음에 실행 될 명령어의 주소를 포함하는 프로그램 카운터를 저장. 오늘날 운영체제는 시분할 처리로 여러 프로세스를 짧은 시간 동안 번갈아 실행한다. 어떤 프로세스가 실행되다가 다른 프로세스에게 CPU를 뺏기고 다시 실행될 때 원래 실행하던 명령어가 실행되어야 하기 때문에 프로그램 카운터가 필요하다.
- 레지스터 정보: 프로세스가 실행될 때 사용했던 레지스터 값들이 저장 (프로그램 카운터와 마찬가지로 CPU를 뺏기고 다시 시작할 때 이전에 사용했던 값을 복구하기 위한 용도)
- 메모리 관련 정보: 프로세스가 메모리에 있는 위치정보, 메모리 침범을 막기 위한 경계레지스터 값등이 저장.
- CPU 스케줄링 정보: CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유시간등이 저장.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 프로세스 상태

사용자가 프로그램을 실행시키면 메모리에 올라가면서 프로세스가 생성된다. 오늘날 운영체제는 동시에 수많은 프로세스를 실행할 수 있다. 작업관리자를 확인해 보면 수많은 프로세스가 실행 중인 것을 확인할 수 있다. 시분할 시스템을 사용하는 운영체제는 여러 개의 프로세스를 돌아가면서 실행한다. CPU가 여러 개의 프로세스를 동시에 실행한다는 말이 아니라 한 순간에는 하나의 프로세스 밖에 처리하지 못한다는 것이다. 프로세스의 상태에는 5가지 상태가 존재한다. 생성, 준비, 실행, 대기, 완료가 있다.

### 생성상태

PCB를 생성하고 메모리에 프로그램 적재 요청을 한 상태이다. 메모리에 프로그램 적재 요청 승인을 받으면 준비상태로 넘어간다.

### 준비상태

CPU를 사용하기 위해 기다리고 있는 상태이다. 준비상태에 있는 프로세스는 이후에 배울 CPU 스케줄러에 의해 CPU가 할당된다. 대부분의 프로세스는 준비상태에 있다.

### 실행상태

준비상태에 있는 프로세스가 CPU 스케줄러에 의해 CPU를 할당받아 실행되는 상태이다. 실행상태에 있는 프로세스의 수는 CPU의 수이다. CPU가 1개라면 프로세스는 최대 1개이다. 실행상태에 있는 프로세스도 CPU를 무한정 쓸 수 있는 것이 아니라 부여된 시간 만큼만 사용할 수 있다. CPU 스케줄러는 부여된 시간을 초과하는 프로세스를 대상으로 CPU를 강제로 뺏는다.(인터럽트) 그럼 프로세스는 다시 준비상태로 넘어간다.

### 대기상태

프로세스가 입출력 요청을 하면 입출력이 완료될 때까지 기다리는 상태이다. 대기상태는 왜 만들어졌을까? CPU는 굉장히 빠른 장치이다. 그에 비해 입출력 작업은 상당히 느린 작업이다. 특정 프로세스가 입출력 요청을 하면 입출력이 완료될 때까지 CPU를 기다리게 하는 것은 비효율적이다. 대신, 입출력 요청 프로세스를 대기상태로 두고 다른 프로세스에게 CPU 할당을 해준다. 그러다가 시간이 지나서 입출력이 완료되면 인터럽트를 CPU에게 보내고 대기상태 프로세스에게 CPU 할당의 기회를 준다. 이렇게 하면 CPU에게 쉬는 시간을 주지 않고 작업을 시킬 수 있다.

### 완료상태

프로세스 종료 상태. 프로세스가 사용했던 데이터를 메모리에서 제거하고 생성된 PCB를 제거한다.

> 이 포스트는 [감자님 강의](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard '인프런 강의')를 기반으로 작성되었습니다.

## 컨텍스트 스위칭

컨텍스트 스위칭은 프로세스를 실행하는 중에 다른 프로세스를 실행하기 위해 실행 중인 프로세스의 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업을 말한다. 컨텍스트 스위칭이 일어날 때 PCB 내용이 변경된다. 실행 중인 프로세스의 작업내용을 PCB에 저장하고 실행될 기존 프로세스의 PCB의 내용대로 CPU가 다시 세팅을 한다.

컨텍스트 스위칭이 일어날 때 PCB에 변경하는 값들로는 프로세스 상태, 다음 실행 할 명령어의 주소를 담고 있는 프로그램 카운터, 각종 레지스터, 메모리 정보가 변경된다. 프로세스 A가 실행하는데 CPU 점유시간을 초과했다고 가정하자. 그러면 운영체제는 프로세스 A가 CPU를 너무 오래 사용했다고 판단하고 인터럽트를 발생시킨다. 프로세스 A는 하던 동작을 멈추고 나중에 현재상태에서 실행되어야 하기 때문에 현재 CPU의 레지스터값등을 PCB A에 저장한다. 이제 PCB B를 참조해서 이전 프로세스 B의 상태로 CPU 레지스터 값을 설정한다. 여기에는 다음 실행 할 명령어의 주소를 가지고 있는 프로그램 카운터를 가지고 있기 때문에 바로 프로세스 B의 명령어를 실행한다.

이런 식으로 메모리에 있는 모든 프로세스들은 컨텍스트 스위칭을 한다. 컨텍스트 스위칭이 발생하는 이유는 다양하다. CPU 점유시간이 다 되거나 입출력 요청이 있거나 다른 종류의 인터럽트가 있을 대 발생한다.
