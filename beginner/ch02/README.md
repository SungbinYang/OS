> 이 포스트는 [널널한 개발자](https://www.inflearn.com/course/%EA%B3%B0%EC%B1%85-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)님의 강의를 듣고 작성한 글입니다.

## CPU도 당신처럼 미리 예측하고 움직인다.

CPU는 연산장치다. 연산장치에서 중요한 것은 연산 속도인데 연산속도가 올라갈수록 연산 양이 늘어나고 처리속도가 올라가 성능이 올라간다. 즉, 클럭속도를 올리는 방향으로 CPU가 개발되다가 어느 순간 한계를 맞아 코어 개수를 늘리는 방향으로 개발되어가고 있다.

여기서 코어는 CPU의 연산처리를 맡아서 한다. 연산을 처리할 데이터는 RAM에 존재한다. 그래서 RAM의 데이터를 CPU 영역까지 읽고 쓰는 것을 반복한다. 그런데 문제는 CPU 안에 레지스터와 RAM의 속도차이가 엄청 커서 그 중간에 완충역할을 하는 애가 있는데 바로 캐시 메모리이다.

캐시 메모리는 종류가 3가지로 나뉘는데 코어마다 붙어있는 L1,L2 캐시메모리가 존재하고 (제조사마다 다름.) CPU에 1개만 존재하는 L3 캐시메모리가 존재한다. 이렇게 캐시메모리를 나누어 놓은 이유는 데이터 양 때문이다. L1은 명령과 데이터로 구분이 되고, L2는 이 2개가 섞여있다. L3는 각 코어마다 명령, 데이터가 섞여있어서 L3에서 각 코어별로 명령과 데이터를 올려 보낸다.

즉, 캐시메모리는 레지스터와 RAM의 속도차이를 극복해 주는 역할을 한다. 그런데 조금 더 재밌는 것은 **예측**은 캐시메모리에서 하는데 이 연산을 캐시가 예측을 할 수 있다. 캐시메모리가 예측을 해서 데이터를 미리 캐시에 담는다. 그리고 코어가 데이터를 필요로 할 때 RAM한테 바로 요청하지 않고 먼저 캐시메모리에게 요청을 한다. 해당 데이터가 캐시에 있으면 예측을 성공했다 하고 전문용어로 **캐시히트**되었다고 한다. 이렇게 해서 성능을 높인다. 하지만 예측이 실패가 되면 **캐시미스**가 되었다고 하고 이럴 경우 RAM한테 정보를 요청한다. 이럴 경우 RAM한테 바로 요청하는 거에 비해 속도가 느리지만 캐시미스가 날 확률은 10%밖에 안되므로 캐시메모리를 사용하는 것이 효율적이다.

정리하자면 RAM의 정보들을 미리 예측하여 CPU가 캐시 메모리에 저장을 해두어서 RAM에서 복사하는 과정을 최소화한다. 물론 CPU 예측이 틀려서 fault가 날 때는 RAM에서 정보를 복사해와야 하는 경우가 있다. 만약 RAM에도 찾는 정보가 없다고 하면 2차 메모리에서 찾아야 하고 거기도 없으면 예외가 발생한다. 프로그래밍으로 치면 `NullPointerException`이 발생하는 것이다.

그럼 예를 들어 언제 캐시메모리가 사용하는지 알아보자. 우리가 코드로 반복문을 실행한다고 보자. 0~99까지 출력을 하는 로직의 코드를 작성한다고 했을 때 이 데이터를 캐시메모리가 미리 가져다 놓는다.

하지만 문제가 있는데, CPU는 너무 고성능이라 엄청 빠른데 RAM은 너무 느리다. 그래서 캐시 메모리가 나왔는데 이렇게 해서 성능을 극대화해왔다. CPU는 연산하는 장치이고 RAM은 데이터와 명령을 담는 장치인데 이 명령과 데이터를 CPU로 가져와서 옮겨서 하는 구조인데 이 패러다임이 요즘 바뀌고 있다.

요즘은 CPU 말고도 연산하는 장치가 있는데 바로 GPU다. GPU는 코어가 4000개 정도 되는데 CPU에 비해 코어성능이 떨어진다. 하지만 병렬로 구성되어 있고 개수가 많기 때문에 CPU와 하는 역할 자체가 다르다. 예를 들어 인형 눈을 붙이는 작업은 이 작업을 하나도 안 해본 대학원생보다 이것을 많이 해본 장인이 더 적절할 것이다. 즉, GPU는 비트코인 채굴도 하지만 AI 인공지능 연산도 한다. 이로 인해 데이터처리가 많이 일어나는데 또 패러다임이 바뀌는 게 PIM이 부상되어서 RAM에서 전처리 연산을 하는 구조로 바뀌고 있다.

예를 들어 요리사가 있고 그 밑에 조수들이 있다. 요리사는 조수들에게 내일 요리를 위해 감자를 깎아놓으라고 명령을 내린다. 그래서 조수들은 감자를 깎지만 PIM은 내일 요리가 어떤 메뉴인지 확인하고 그에 맞게 감자를 깎고 다져놓는 작업까지 하는 것으로 비유를 할 수 있다.

> 이 포스트는 [널널한 개발자](https://www.inflearn.com/course/%EA%B3%B0%EC%B1%85-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)님의 강의를 듣고 작성한 글입니다.  
> [블로그](https://parksb.github.io/article/31.html)  
> [나무위키](https://namu.wiki/w/CPU%20%EA%B2%8C%EC%9D%B4%ED%8A%B8)

## CPU 예측이 가져올 수 있는 문제점

I/O 관리자가 CPU의 연산을 보고 미리 예측해서 명령과 데이터를 가져온다. 그런데 여기서 핵심은 '시키지도 않은 일'이라는 것이다. 그래서 심각한 사고가 발생했는데 바로 CPU 게이트 사건이다. 흔히 'Meltdown' 혹은 'Spectre'라는 것이다.

예를 들어보자. 해외 순방 중인 대통령을 암살하려는 범죄조직이 있다고 하자. 이 조직은 대통령이 어느 호텔의 A동에 묵는다는 것까지는 알아냈다. 그러나, 몇 호실에 있는지는 알아내지 못했다. 여기서는 A동 202호라고 하자. 대통령 관련 정보는 당연히 1급도 아닌 극비사항이므로 호텔 프런트에는 "A동 관련 질문은 일절 답변하지 말라"는 엄명이 내려와 있다. 따라서 "대통령이 A동 몇 호실에 묵고 있나요?"라고 물어봐도 당연히 "대답해 드릴 수 없습니다."라는 답변만 돌아올 뿐이다. 여기서 조직원은 잔머리를 굴려 프런트 직원의 노하우를 역이용하기로 한다. 프런트 직원은 다음과 같이 일을 처리한다고 알려져 있다.

> 1\. 특정 호실에 대한 문의가 자주 들어오면 직원은 그 방을 시스템에서 자꾸 검색하는 수고를 덜기 위해 해당 방의 정보를 메모지에 적어 놓는다.
>
> 2\. 메모지에 적어놓은 방의 정보는 검색하지 않고 메모지를 참고해 다른 방에 비해 훨씬 빠르게 대답해 준다.
>
> 3\. 메모지에 뭐라고 적혀있는지 직접 묻는 질문에는 대답하지 않는다.

여기서 1번이 어떠한 메모리에 대해 참조를 하면 그것을 캐싱하겠다는 의미이다. 하지만 여기서 문제는 해커들이 이를 역이용한다는 것이다.

작전 1단계. 우선 질문을 다음과 같이 바꾼다.

> "B동 호텔방 중 A동의 대통령이 묵는 호실과 같은 호실이 비어있나요?"

A동 관련 질문이 들어갔기 때문에 직원은 여전히 "대답해 드릴 수 없습니다."라고만 대답할 뿐이다. 그런데 상기했듯 프런트 직원은 특정 방에 대한 문의가 많이 들어온다 싶으면 호텔 시스템을 계속 뒤져보는 번거로움을 덜기 위해 해당 방의 정보를 메모지에 적어 놓는 습관이 있다. 이제 저 질문을 계속 반복해서 직원의 귀차니즘을 자극해 보자. 그러면 직원은 계속 "대답해 드릴 수 없습니다."라고 대답은 하면서도 메모지에다가는 문제의 "B동 호텔방 중 A동의 대통령이 묵는 호실과 같은 호실", 즉 B동 202호의 정보를 적어 놓을 것이다.

직원의 귀차니즘을 충분히 자극했다 싶으면 작전 2단계로 간다. 작전의 목표는 메모지에 적힌 호실이 어디인지 알아내는 것. 다만 상기했듯 메모지의 내용을 직접 묻는 질문에는 여전히 답변을 거부한다. 하지만 간접적으로 알아낼 방법은 있다. 바로 "2. 메모지에 적어놓은 방의 정보는 검색하지 않고 메모지를 참고해 다른 방에 비해 훨씬 빠르게 대답해 준다."를 이용하는 것. 이를 위해 "A동"이라는 말은 싹 빼고 B동에 있는 모든 방에 대해 직원에게 무작위로 캐묻는다.

> "B동 408호 비어 있나요?"  
> "B동 105호 비어 있나요?"  
> "B동 803호 비어 있나요?"  
> ...

이런 식. 방의 정보를 순서대로가 아닌 무작위로 캐묻는 이유는, 순서대로 물어보면 규칙을 예측한 프런트 직원이 물어보는 방 정보의 뒷방 정보를 메모지에 미리미리 적어놓아서 빨리 대답해버리기 때문에 귀차니즘을 자극한 게 무용지물이 될 수 있기 때문이다.

A동 관련 질문은 일절 답변하지 말라는 엄명이 내려와 있지만, B동에 대해서는 특별한 지침이 내려오지 않았기 때문에 직원은 모두 순순히 대답을 해 줄 것이며, 물어볼 때마다 아무것도 모르는 프런트 직원은 호텔 시스템을 검색하기 위해 "잠시만요..." 하며 뜸을 들일 것이다. 하지만 문제의 "B동 호텔방 중 A동의 대통령이 묵는 호실과 같은 호실", 즉 B동 202호는 프론트 직원이 이미 메모지에 적어 놓아서, 호텔 시스템을 검색할 필요 없이 뜸을 들이지 않고 바로 대답해줄 수 있다. 그리고 조직원은 이로부터 프론트 직원이 메모지에 써놓은 호실이 B동 202호임을 알 수 있게 되는 것이다. 여기서 B동을 A동으로만 바꾸면 거기에 대통령이 있다는 것을 알 수 있다. 일을 효율적으로 하기 위한 프론트 직원의 노하우가 여기서는 오히려 기밀정보를 유출시켜 대통령을 위험에 빠뜨리는 결정적인 계기로 작용하는 것이다.

즉 실제로 보면 메모리를 아무 데나 무작위로 참조를 한다. 그리고 CPU가 예측한 것과 다른 곳을 참조한다. 그렇게 수차례 하면 원하던 메모리를 캐싱이 될 것이고 그 메모리를 참조할 수 있다. 그러면 해커들은 그 메모리를 참조해서 무엇을 알아내려 하는 것일까? 램에서는 일정 I/O Address range를 특정 장치가 점유한다. 예를 들어 키보드라고 보면 I/O Address range에 우리가 타자 친 내용이 다 들어가져 있다. 이렇게 우리가 타자 친 내용들을 알 수 있는 것이다. 또 예를 들면 해커가 특정 메모리를 참조하라는 user-mode application을 작동시키면 이 특정 메모리를 read 할 수 있는 권한은 system call(커널)밖에 없어서 권한오류가 나오고 동작을 안 한다. 하지만 실제로는 권한과 상관없이 연산이 일어나고 보여주지 않을 뿐이다. 이 점을 노리는 것이다.

즉, 해커가 시킨 일을 하기 위해 CPU는 다음의 일을 해야 한다.

> 1\. 100번 방에서 숫자를 꺼낸다.
>
> 2\. 100번 방에서 꺼낸 숫자를 레지스터 al에 임시로 저장한다.
>
> 3\. al에 저장된 숫자와 1000을 더한다. (여기에서는 1097로 가정하자.)
>
> 4\. 3에서 더한 결과에 해당하는 RAM의 숫자를 꺼낸다. (즉, 1097번 방의 자료를 꺼낸다.)
>
> 5\. 꺼낸 숫자를 해커에게 전달한다.

상기에 서술한 대로, 이 일련의 과정들은 권한 오류를 일으킨다.

문제는 CPU의 파이프라인 구조에 있다. 해커가 100번 방의 숫자를 꺼내라고 했을 때, CPU는 권한 여부에 상관없이 일단 100번 방의 숫자를 꺼낸다. 그리고 RAM의 1097번 방의 숫자도 꺼낸다. 즉, 실제로 CPU는 해커가 시킨 일을 다 한다. 단지 보여주지 않을 뿐이다. 예전까지는 해커한테 보여주지만 않으면 괜찮다고 생각했기 때문에 이런 방식이 사용되었다. **'CPU가 일을 다 하고 보여주지만 않으니, CPU가 일한 흔적을 찾아 100번 방의 숫자를 알아내자'**라는 것이 멜트다운 버그의 핵심 아이디어이다.

더 대박은 가상화 환경에서 난리가 났다.

> 1\. Guest0번에서 악성코드 등장
>
> 2\. 같은 CPU내의 VM에서 프로세스 동작 및 실제 CPU에 데이터 전달 및 RAM에 저장 (코어에 전달)
>
> 3\. 연산을 하는 고장에 캐싱 후 동작
>
> 4\. 악성 코드가 무작위로 RAM 메모리 참조
>
> 5\. 결국 VM 프로세스 자동 캐싱
>
> 6\. 즉, Guest2 VM에서 Guest0 VM의 메모리를 참조하는 기적 발생

이 예로 우리가 AWS를 이용하여 웹서버를 이용하고 있다고 보자. 거기에는 인증서도 있고 각종 코드도 있을 것이다. 위에 설명한 방법으로 AWS에 우리의 인증서가 털리는 경우가 발생한다.

> 이 포스트는 [널널한 개발자](https://www.inflearn.com/course/%EA%B3%B0%EC%B1%85-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)님의 강의를 듣고 작성한 글입니다.  
> [참고자료](https://itwiki.kr/w/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C)

## 프로세스와 스레드

컴퓨터에서 자원은 CPU를 사용하는 경우와 RAM을 사용하는 경우가 있다. 또한 HDD같은 2차 메모리에서도 사용을 한다. 여기서 RAM + HDD를 Virtual Memory형태로 관리를 한다.

### 프로세스 개념

즉, 자원이라고 하면 첫째 CPU, 둘째 (user mode application process) Virtual Memory이다. 그래서 자원이라고 하는 것을 운영체제마다 다르겠지만 기본적으로 프로세스한테 준다. 윈도우 OS기준으로는 스레드 기준으로 CPU를 준다. 또한 Virtual Memory같은 것은 process단위로 주어진다. 또한 OS입장에서 프로세스를 관리를 해야하는데 그것을 위해 등장하는게 바로 PCB이다. PCB한테 운영체제가 어떤 관리에 필요한 정보를 잔뜩 담아두고 그 정보를 가지고 프로세스를 관리를 한다.

프로세스는 스레드안에 소속이 된다. 이 스레드들은 프로세스에게 주어진 가상메모리 공간에 자유자재로 접근이 가능하다. CPU는 연산하는 장치이고 연산하는 주체가 Core인데 Core가 8개를지닌 CPU가 있다고 가정을 해보자. 만약 2000개의 연산할 거리가 있는데 이 2000개가 8개의 Core한테 연산해달라고 하면 병목현상이 발생할 것이다. 그래서 OS는 2000개의 연산할거리들을 줄을 세워 관리한다.

아무튼 CPU라는 자원을 2000개의 스레드가 점유할려고 하면 이 CPU 자원을 시분할해서 사용한다. 여기서 시분할이랑 동시성개념처럼 번갈아가면 자원을 점유한다는 말이다. 그런데 우리는 이것을 못느끼는 이유가 사용속도가 1ns정도로 엄청 빠르기 때문에 우리가 느끼지 못하는 것뿐이다.

### 프로그램에서 프로세스로의 전환

그러면 PCB에는 어떤 정보가 들어가 있을까? 첫째로 PID라고 들어가 있는데 이는 프로세스 ID값이고 이 ID값은 양의 정수로 32bit체제로 들어가 있다. 두번째로 메모리 관련정보가 들어가 있는데 Virtual Memory 시스템 속에는 Stack 영역(지역변수, 매개변수등 저장), heap 영역(malloc같은 걸로 할당받은 메모리 저장), Code가 저장되는 영역이 있는데 이 Code안에 text section (함수 포인터같은 걸로 명령 접근)이 존재하는데 여기에는 기계어가 저장되어 있다. 이 기계어도 Virtual Memory안에 있으니 순차적으로 저장되어 있는데 명령을 실행할 때 이 명령들의 메모리 주소가 있는데 이렇게 실행된 기계어의 명령들의 메모리 주소를 PCB에 담는다. 또한 static 영역이 존재하는데 이 영역에는 Read전용과 Read/Write용도가 있는데 이는 각각 상수, 전역변수를 저장을 한다.

MS Word같은 프로그램을 하드에 설치하고 설치된 프로그램을 RAM 메모리에 올리는데 이것을 인스턴스화라고 하고 쉽게 말하면 실행한다라고 불린다. 인스턴스화가 되면서 PCB도 생성하고 가상메모리도 할당받고 이때부터 프로그램이라고 부르지 않고 프로세스라고 부른다.

### 프로세스 4가지 상태

프로세스에는 4가지 상태가 존재하는데 이 상태들은 전이된다. 각 상태들은 말 그대로이며 OS입장에서 프로세스를 관리할때 쓰레드들(ready 상태)을 자료구조 Queue에 넣어서 줄을 세우는데 Queue의 앞에 있는 쓰레드부터 꺼내서 디스패치해서 연산을 한다. 이때 코어가 8개이면 8개를 한번에 꺼낸다. 실행은 프로세스 위주로 설명을 하는데 이것은 Linux, Unix중심이고 Window는 쓰레드 중심으로 설명을 한다.

또한 입출력 요청을 프로세스가 했을 때 응답이 올때까지 Lock이 걸렸다(대기상태)는 것은 blocking I/O 아니면 non-blocking I/O이다. 즉, 비동기 입출력을 할 때 중요한 것은 입출력을 요청한 요청자의 상태가 어떻게 가느냐에 따라 중요하다. 요청하고 실행상태면 non-blocking I/O, 대기상태면 blocking I/O이다.

> 이 포스트는 [널널한 개발자](https://www.inflearn.com/course/%EA%B3%B0%EC%B1%85-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)님의 강의를 듣고 작성한 글입니다.

## 프로세스 휴식, 보류 상태와 문맥

프로세스 상태는 이전 포스트에서 설명한 상태 말고도 중요한 상태가 sleep상태와 suspend상태가 있다. sleep상태와 suspend상태는 둘 다 보류상태지만 좀 다른 부분이 존재한다.

suspend상태는 OS 혹은 다른 프로세스로부터 강제된 상태를 말하는데 즉 의도치 않은 요인으로 그 원인이 swap날때 (가상메모리 상태에서 보류상태나 대기상태가 너무 오래될 때) 혹은 프로그램이 죽을 때 발생하고 sleep상태는 자발적으로 된 상태로 우리가 코드로 `Thread.sleep(10)`을 쓴 상태로 볼 수 있다.

중요한 것은 Ready-Queue에서 쓰레드가 sleep이나 suspend를 하면 이 대기열에서 이탈을 하는데 예를 들어 sleep(10) 함수를 호출하면 10ms만큼만 쉬는 게 아니라 + @만큼 더 쉬는데 이 @가 대기열에 이탈했다가 10ms후 대기열에 진입을 한다. 그러면 재진입된 스레드는 앞에 대기열이 연산을 다 처리 후 수행이 되는데 그 시간이 @이다. 그래서 앞에 대기열에 따라 @시간이 달라짐으로 어느 누구도 장담하기 힘들다. 이 과정은 suspend상태도 마찬가지다. 구체적으로 보면 쓰레드가 작업을 하다 suspend든 sleep든 만나면 일시정지가 되는데 이때 흐름이 정지되고 문맥을 이어나가기 위한 상태가 PCB에 저장이 되는데 여기에 저장되는 것들은 프로세스 구분자, 프로세스 카운터, 프로세스 우선순위, 각종 레지스터 정보, 메모리 관련정보, 할당된 자원정보 등이 저장된다. 그 이후 다시 스케줄링돼서 연산할 차례가 되면 흐름이 이어가는데 이때 나오는 말이 Context이다. 예를 들어 프로그램 A,B,C가 있다고 해보자. 프로그램마다 각자 흐름이 있을 텐데 A, B, C 각각 어느 정도 하다 멈췄다고 해보자. 코어가 1개면 3개 중에 1개만 연산을 하고 나머지는 멈출 텐데 A문맥을 이어가다 B로 바뀌었을 때 Context Switching 되었다고 볼 수 있다.

결론적으로 프로세스가 실행이 되면 연산을 하고 연산을 할때마다 상태가 변화를 할 텐데 이 상태변화가 register에 전부 기록이 되어있고 이 기록을 담은 레지스터들이 여러 존재한다.
