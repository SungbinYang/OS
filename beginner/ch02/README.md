> 이 포스트는 [널널한 개발자](https://www.inflearn.com/course/%EA%B3%B0%EC%B1%85-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)님의 강의를 듣고 작성한 글입니다.

## CPU도 당신처럼 미리 예측하고 움직인다.

CPU는 연산장치다. 연산장치에서 중요한 것은 연산 속도인데 연산속도가 올라갈수록 연산 양이 늘어나고 처리속도가 올라가 성능이 올라간다. 즉, 클럭속도를 올리는 방향으로 CPU가 개발되다가 어느 순간 한계를 맞아 코어 개수를 늘리는 방향으로 개발되어가고 있다.

여기서 코어는 CPU의 연산처리를 맡아서 한다. 연산을 처리할 데이터는 RAM에 존재한다. 그래서 RAM의 데이터를 CPU 영역까지 읽고 쓰는 것을 반복한다. 그런데 문제는 CPU 안에 레지스터와 RAM의 속도차이가 엄청 커서 그 중간에 완충역할을 하는 애가 있는데 바로 캐시 메모리이다.

캐시 메모리는 종류가 3가지로 나뉘는데 코어마다 붙어있는 L1,L2 캐시메모리가 존재하고 (제조사마다 다름.) CPU에 1개만 존재하는 L3 캐시메모리가 존재한다. 이렇게 캐시메모리를 나누어 놓은 이유는 데이터 양 때문이다. L1은 명령과 데이터로 구분이 되고, L2는 이 2개가 섞여있다. L3는 각 코어마다 명령, 데이터가 섞여있어서 L3에서 각 코어별로 명령과 데이터를 올려 보낸다.

즉, 캐시메모리는 레지스터와 RAM의 속도차이를 극복해 주는 역할을 한다. 그런데 조금 더 재밌는 것은 **예측**은 캐시메모리에서 하는데 이 연산을 캐시가 예측을 할 수 있다. 캐시메모리가 예측을 해서 데이터를 미리 캐시에 담는다. 그리고 코어가 데이터를 필요로 할 때 RAM한테 바로 요청하지 않고 먼저 캐시메모리에게 요청을 한다. 해당 데이터가 캐시에 있으면 예측을 성공했다 하고 전문용어로 **캐시히트**되었다고 한다. 이렇게 해서 성능을 높인다. 하지만 예측이 실패가 되면 **캐시미스**가 되었다고 하고 이럴 경우 RAM한테 정보를 요청한다. 이럴 경우 RAM한테 바로 요청하는 거에 비해 속도가 느리지만 캐시미스가 날 확률은 10%밖에 안되므로 캐시메모리를 사용하는 것이 효율적이다.

정리하자면 RAM의 정보들을 미리 예측하여 CPU가 캐시 메모리에 저장을 해두어서 RAM에서 복사하는 과정을 최소화한다. 물론 CPU 예측이 틀려서 fault가 날 때는 RAM에서 정보를 복사해와야 하는 경우가 있다. 만약 RAM에도 찾는 정보가 없다고 하면 2차 메모리에서 찾아야 하고 거기도 없으면 예외가 발생한다. 프로그래밍으로 치면 `NullPointerException`이 발생하는 것이다.

그럼 예를 들어 언제 캐시메모리가 사용하는지 알아보자. 우리가 코드로 반복문을 실행한다고 보자. 0~99까지 출력을 하는 로직의 코드를 작성한다고 했을 때 이 데이터를 캐시메모리가 미리 가져다 놓는다.

하지만 문제가 있는데, CPU는 너무 고성능이라 엄청 빠른데 RAM은 너무 느리다. 그래서 캐시 메모리가 나왔는데 이렇게 해서 성능을 극대화해왔다. CPU는 연산하는 장치이고 RAM은 데이터와 명령을 담는 장치인데 이 명령과 데이터를 CPU로 가져와서 옮겨서 하는 구조인데 이 패러다임이 요즘 바뀌고 있다.

요즘은 CPU 말고도 연산하는 장치가 있는데 바로 GPU다. GPU는 코어가 4000개 정도 되는데 CPU에 비해 코어성능이 떨어진다. 하지만 병렬로 구성되어 있고 개수가 많기 때문에 CPU와 하는 역할 자체가 다르다. 예를 들어 인형 눈을 붙이는 작업은 이 작업을 하나도 안 해본 대학원생보다 이것을 많이 해본 장인이 더 적절할 것이다. 즉, GPU는 비트코인 채굴도 하지만 AI 인공지능 연산도 한다. 이로 인해 데이터처리가 많이 일어나는데 또 패러다임이 바뀌는 게 PIM이 부상되어서 RAM에서 전처리 연산을 하는 구조로 바뀌고 있다.

예를 들어 요리사가 있고 그 밑에 조수들이 있다. 요리사는 조수들에게 내일 요리를 위해 감자를 깎아놓으라고 명령을 내린다. 그래서 조수들은 감자를 깎지만 PIM은 내일 요리가 어떤 메뉴인지 확인하고 그에 맞게 감자를 깎고 다져놓는 작업까지 하는 것으로 비유를 할 수 있다.

> 이 포스트는 [널널한 개발자](https://www.inflearn.com/course/%EA%B3%B0%EC%B1%85-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)님의 강의를 듣고 작성한 글입니다.  
> [블로그](https://parksb.github.io/article/31.html)  
> [나무위키](https://namu.wiki/w/CPU%20%EA%B2%8C%EC%9D%B4%ED%8A%B8)

## CPU 예측이 가져올 수 있는 문제점

I/O 관리자가 CPU의 연산을 보고 미리 예측해서 명령과 데이터를 가져온다. 그런데 여기서 핵심은 '시키지도 않은 일'이라는 것이다. 그래서 심각한 사고가 발생했는데 바로 CPU 게이트 사건이다. 흔히 'Meltdown' 혹은 'Spectre'라는 것이다.

예를 들어보자. 해외 순방 중인 대통령을 암살하려는 범죄조직이 있다고 하자. 이 조직은 대통령이 어느 호텔의 A동에 묵는다는 것까지는 알아냈다. 그러나, 몇 호실에 있는지는 알아내지 못했다. 여기서는 A동 202호라고 하자. 대통령 관련 정보는 당연히 1급도 아닌 극비사항이므로 호텔 프런트에는 "A동 관련 질문은 일절 답변하지 말라"는 엄명이 내려와 있다. 따라서 "대통령이 A동 몇 호실에 묵고 있나요?"라고 물어봐도 당연히 "대답해 드릴 수 없습니다."라는 답변만 돌아올 뿐이다. 여기서 조직원은 잔머리를 굴려 프런트 직원의 노하우를 역이용하기로 한다. 프런트 직원은 다음과 같이 일을 처리한다고 알려져 있다.

> 1\. 특정 호실에 대한 문의가 자주 들어오면 직원은 그 방을 시스템에서 자꾸 검색하는 수고를 덜기 위해 해당 방의 정보를 메모지에 적어 놓는다.
>
> 2\. 메모지에 적어놓은 방의 정보는 검색하지 않고 메모지를 참고해 다른 방에 비해 훨씬 빠르게 대답해 준다.
>
> 3\. 메모지에 뭐라고 적혀있는지 직접 묻는 질문에는 대답하지 않는다.

여기서 1번이 어떠한 메모리에 대해 참조를 하면 그것을 캐싱하겠다는 의미이다. 하지만 여기서 문제는 해커들이 이를 역이용한다는 것이다.

작전 1단계. 우선 질문을 다음과 같이 바꾼다.

> "B동 호텔방 중 A동의 대통령이 묵는 호실과 같은 호실이 비어있나요?"

A동 관련 질문이 들어갔기 때문에 직원은 여전히 "대답해 드릴 수 없습니다."라고만 대답할 뿐이다. 그런데 상기했듯 프런트 직원은 특정 방에 대한 문의가 많이 들어온다 싶으면 호텔 시스템을 계속 뒤져보는 번거로움을 덜기 위해 해당 방의 정보를 메모지에 적어 놓는 습관이 있다. 이제 저 질문을 계속 반복해서 직원의 귀차니즘을 자극해 보자. 그러면 직원은 계속 "대답해 드릴 수 없습니다."라고 대답은 하면서도 메모지에다가는 문제의 "B동 호텔방 중 A동의 대통령이 묵는 호실과 같은 호실", 즉 B동 202호의 정보를 적어 놓을 것이다.

직원의 귀차니즘을 충분히 자극했다 싶으면 작전 2단계로 간다. 작전의 목표는 메모지에 적힌 호실이 어디인지 알아내는 것. 다만 상기했듯 메모지의 내용을 직접 묻는 질문에는 여전히 답변을 거부한다. 하지만 간접적으로 알아낼 방법은 있다. 바로 "2. 메모지에 적어놓은 방의 정보는 검색하지 않고 메모지를 참고해 다른 방에 비해 훨씬 빠르게 대답해 준다."를 이용하는 것. 이를 위해 "A동"이라는 말은 싹 빼고 B동에 있는 모든 방에 대해 직원에게 무작위로 캐묻는다.

> "B동 408호 비어 있나요?"  
> "B동 105호 비어 있나요?"  
> "B동 803호 비어 있나요?"  
> ...

이런 식. 방의 정보를 순서대로가 아닌 무작위로 캐묻는 이유는, 순서대로 물어보면 규칙을 예측한 프런트 직원이 물어보는 방 정보의 뒷방 정보를 메모지에 미리미리 적어놓아서 빨리 대답해버리기 때문에 귀차니즘을 자극한 게 무용지물이 될 수 있기 때문이다.

A동 관련 질문은 일절 답변하지 말라는 엄명이 내려와 있지만, B동에 대해서는 특별한 지침이 내려오지 않았기 때문에 직원은 모두 순순히 대답을 해 줄 것이며, 물어볼 때마다 아무것도 모르는 프런트 직원은 호텔 시스템을 검색하기 위해 "잠시만요..." 하며 뜸을 들일 것이다. 하지만 문제의 "B동 호텔방 중 A동의 대통령이 묵는 호실과 같은 호실", 즉 B동 202호는 프론트 직원이 이미 메모지에 적어 놓아서, 호텔 시스템을 검색할 필요 없이 뜸을 들이지 않고 바로 대답해줄 수 있다. 그리고 조직원은 이로부터 프론트 직원이 메모지에 써놓은 호실이 B동 202호임을 알 수 있게 되는 것이다. 여기서 B동을 A동으로만 바꾸면 거기에 대통령이 있다는 것을 알 수 있다. 일을 효율적으로 하기 위한 프론트 직원의 노하우가 여기서는 오히려 기밀정보를 유출시켜 대통령을 위험에 빠뜨리는 결정적인 계기로 작용하는 것이다.

즉 실제로 보면 메모리를 아무 데나 무작위로 참조를 한다. 그리고 CPU가 예측한 것과 다른 곳을 참조한다. 그렇게 수차례 하면 원하던 메모리를 캐싱이 될 것이고 그 메모리를 참조할 수 있다. 그러면 해커들은 그 메모리를 참조해서 무엇을 알아내려 하는 것일까? 램에서는 일정 I/O Address range를 특정 장치가 점유한다. 예를 들어 키보드라고 보면 I/O Address range에 우리가 타자 친 내용이 다 들어가져 있다. 이렇게 우리가 타자 친 내용들을 알 수 있는 것이다. 또 예를 들면 해커가 특정 메모리를 참조하라는 user-mode application을 작동시키면 이 특정 메모리를 read 할 수 있는 권한은 system call(커널)밖에 없어서 권한오류가 나오고 동작을 안 한다. 하지만 실제로는 권한과 상관없이 연산이 일어나고 보여주지 않을 뿐이다. 이 점을 노리는 것이다.

즉, 해커가 시킨 일을 하기 위해 CPU는 다음의 일을 해야 한다.

> 1\. 100번 방에서 숫자를 꺼낸다.
>
> 2\. 100번 방에서 꺼낸 숫자를 레지스터 al에 임시로 저장한다.
>
> 3\. al에 저장된 숫자와 1000을 더한다. (여기에서는 1097로 가정하자.)
>
> 4\. 3에서 더한 결과에 해당하는 RAM의 숫자를 꺼낸다. (즉, 1097번 방의 자료를 꺼낸다.)
>
> 5\. 꺼낸 숫자를 해커에게 전달한다.

상기에 서술한 대로, 이 일련의 과정들은 권한 오류를 일으킨다.

문제는 CPU의 파이프라인 구조에 있다. 해커가 100번 방의 숫자를 꺼내라고 했을 때, CPU는 권한 여부에 상관없이 일단 100번 방의 숫자를 꺼낸다. 그리고 RAM의 1097번 방의 숫자도 꺼낸다. 즉, 실제로 CPU는 해커가 시킨 일을 다 한다. 단지 보여주지 않을 뿐이다. 예전까지는 해커한테 보여주지만 않으면 괜찮다고 생각했기 때문에 이런 방식이 사용되었다. **'CPU가 일을 다 하고 보여주지만 않으니, CPU가 일한 흔적을 찾아 100번 방의 숫자를 알아내자'**라는 것이 멜트다운 버그의 핵심 아이디어이다.

더 대박은 가상화 환경에서 난리가 났다.

> 1\. Guest0번에서 악성코드 등장
>
> 2\. 같은 CPU내의 VM에서 프로세스 동작 및 실제 CPU에 데이터 전달 및 RAM에 저장 (코어에 전달)
>
> 3\. 연산을 하는 고장에 캐싱 후 동작
>
> 4\. 악성 코드가 무작위로 RAM 메모리 참조
>
> 5\. 결국 VM 프로세스 자동 캐싱
>
> 6\. 즉, Guest2 VM에서 Guest0 VM의 메모리를 참조하는 기적 발생

이 예로 우리가 AWS를 이용하여 웹서버를 이용하고 있다고 보자. 거기에는 인증서도 있고 각종 코드도 있을 것이다. 위에 설명한 방법으로 AWS에 우리의 인증서가 털리는 경우가 발생한다.

> 이 포스트는 [널널한 개발자](https://www.inflearn.com/course/%EA%B3%B0%EC%B1%85-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)님의 강의를 듣고 작성한 글입니다.  
> [참고자료](https://itwiki.kr/w/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C)

## 프로세스와 스레드

컴퓨터에서 자원은 CPU를 사용하는 경우와 RAM을 사용하는 경우가 있다. 또한 HDD같은 2차 메모리에서도 사용을 한다. 여기서 RAM + HDD를 Virtual Memory형태로 관리를 한다.

### 프로세스 개념

즉, 자원이라고 하면 첫째 CPU, 둘째 (user mode application process) Virtual Memory이다. 그래서 자원이라고 하는 것을 운영체제마다 다르겠지만 기본적으로 프로세스한테 준다. 윈도우 OS기준으로는 스레드 기준으로 CPU를 준다. 또한 Virtual Memory같은 것은 process단위로 주어진다. 또한 OS입장에서 프로세스를 관리를 해야하는데 그것을 위해 등장하는게 바로 PCB이다. PCB한테 운영체제가 어떤 관리에 필요한 정보를 잔뜩 담아두고 그 정보를 가지고 프로세스를 관리를 한다.

프로세스는 스레드안에 소속이 된다. 이 스레드들은 프로세스에게 주어진 가상메모리 공간에 자유자재로 접근이 가능하다. CPU는 연산하는 장치이고 연산하는 주체가 Core인데 Core가 8개를지닌 CPU가 있다고 가정을 해보자. 만약 2000개의 연산할 거리가 있는데 이 2000개가 8개의 Core한테 연산해달라고 하면 병목현상이 발생할 것이다. 그래서 OS는 2000개의 연산할거리들을 줄을 세워 관리한다.

아무튼 CPU라는 자원을 2000개의 스레드가 점유할려고 하면 이 CPU 자원을 시분할해서 사용한다. 여기서 시분할이랑 동시성개념처럼 번갈아가면 자원을 점유한다는 말이다. 그런데 우리는 이것을 못느끼는 이유가 사용속도가 1ns정도로 엄청 빠르기 때문에 우리가 느끼지 못하는 것뿐이다.

### 프로그램에서 프로세스로의 전환

그러면 PCB에는 어떤 정보가 들어가 있을까? 첫째로 PID라고 들어가 있는데 이는 프로세스 ID값이고 이 ID값은 양의 정수로 32bit체제로 들어가 있다. 두번째로 메모리 관련정보가 들어가 있는데 Virtual Memory 시스템 속에는 Stack 영역(지역변수, 매개변수등 저장), heap 영역(malloc같은 걸로 할당받은 메모리 저장), Code가 저장되는 영역이 있는데 이 Code안에 text section (함수 포인터같은 걸로 명령 접근)이 존재하는데 여기에는 기계어가 저장되어 있다. 이 기계어도 Virtual Memory안에 있으니 순차적으로 저장되어 있는데 명령을 실행할 때 이 명령들의 메모리 주소가 있는데 이렇게 실행된 기계어의 명령들의 메모리 주소를 PCB에 담는다. 또한 static 영역이 존재하는데 이 영역에는 Read전용과 Read/Write용도가 있는데 이는 각각 상수, 전역변수를 저장을 한다.

MS Word같은 프로그램을 하드에 설치하고 설치된 프로그램을 RAM 메모리에 올리는데 이것을 인스턴스화라고 하고 쉽게 말하면 실행한다라고 불린다. 인스턴스화가 되면서 PCB도 생성하고 가상메모리도 할당받고 이때부터 프로그램이라고 부르지 않고 프로세스라고 부른다.

### 프로세스 4가지 상태

프로세스에는 4가지 상태가 존재하는데 이 상태들은 전이된다. 각 상태들은 말 그대로이며 OS입장에서 프로세스를 관리할때 쓰레드들(ready 상태)을 자료구조 Queue에 넣어서 줄을 세우는데 Queue의 앞에 있는 쓰레드부터 꺼내서 디스패치해서 연산을 한다. 이때 코어가 8개이면 8개를 한번에 꺼낸다. 실행은 프로세스 위주로 설명을 하는데 이것은 Linux, Unix중심이고 Window는 쓰레드 중심으로 설명을 한다.

또한 입출력 요청을 프로세스가 했을 때 응답이 올때까지 Lock이 걸렸다(대기상태)는 것은 blocking I/O 아니면 non-blocking I/O이다. 즉, 비동기 입출력을 할 때 중요한 것은 입출력을 요청한 요청자의 상태가 어떻게 가느냐에 따라 중요하다. 요청하고 실행상태면 non-blocking I/O, 대기상태면 blocking I/O이다.

> 이 포스트는 [널널한 개발자](https://www.inflearn.com/course/%EA%B3%B0%EC%B1%85-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)님의 강의를 듣고 작성한 글입니다.

## 프로세스 휴식, 보류 상태와 문맥

프로세스 상태는 이전 포스트에서 설명한 상태 말고도 중요한 상태가 sleep상태와 suspend상태가 있다. sleep상태와 suspend상태는 둘 다 보류상태지만 좀 다른 부분이 존재한다.

suspend상태는 OS 혹은 다른 프로세스로부터 강제된 상태를 말하는데 즉 의도치 않은 요인으로 그 원인이 swap날때 (가상메모리 상태에서 보류상태나 대기상태가 너무 오래될 때) 혹은 프로그램이 죽을 때 발생하고 sleep상태는 자발적으로 된 상태로 우리가 코드로 `Thread.sleep(10)`을 쓴 상태로 볼 수 있다.

중요한 것은 Ready-Queue에서 쓰레드가 sleep이나 suspend를 하면 이 대기열에서 이탈을 하는데 예를 들어 sleep(10) 함수를 호출하면 10ms만큼만 쉬는 게 아니라 + @만큼 더 쉬는데 이 @가 대기열에 이탈했다가 10ms후 대기열에 진입을 한다. 그러면 재진입된 스레드는 앞에 대기열이 연산을 다 처리 후 수행이 되는데 그 시간이 @이다. 그래서 앞에 대기열에 따라 @시간이 달라짐으로 어느 누구도 장담하기 힘들다. 이 과정은 suspend상태도 마찬가지다. 구체적으로 보면 쓰레드가 작업을 하다 suspend든 sleep든 만나면 일시정지가 되는데 이때 흐름이 정지되고 문맥을 이어나가기 위한 상태가 PCB에 저장이 되는데 여기에 저장되는 것들은 프로세스 구분자, 프로세스 카운터, 프로세스 우선순위, 각종 레지스터 정보, 메모리 관련정보, 할당된 자원정보 등이 저장된다. 그 이후 다시 스케줄링돼서 연산할 차례가 되면 흐름이 이어가는데 이때 나오는 말이 Context이다. 예를 들어 프로그램 A,B,C가 있다고 해보자. 프로그램마다 각자 흐름이 있을 텐데 A, B, C 각각 어느 정도 하다 멈췄다고 해보자. 코어가 1개면 3개 중에 1개만 연산을 하고 나머지는 멈출 텐데 A문맥을 이어가다 B로 바뀌었을 때 Context Switching 되었다고 볼 수 있다.

결론적으로 프로세스가 실행이 되면 연산을 하고 연산을 할때마다 상태가 변화를 할 텐데 이 상태변화가 register에 전부 기록이 되어있고 이 기록을 담은 레지스터들이 여러 존재한다.

> 이 포스트는 [널널한 개발자](https://www.inflearn.com/course/%EA%B3%B0%EC%B1%85-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)님의 강의를 듣고 작성한 글입니다.  
> [참고자료](https://woochan-autobiography.tistory.com/207)

## 프로세스 생성과 복사

| **Win32 API**         | **Unix**       |
| --------------------- | -------------- |
| createProcess()       | fork(), exec() |
| ExitProcess()         | exit()         |
| waitForSingleObject() | wait()         |

가상메모리 얘기를 하면 항상 따라다니는 놈이 process다. process단위로 OS가 접근제어를 하는데 파일이나 여러 자원에 대한 접근제어를 의미한다. 어떤 프로세스에 대해 OS가 접근허가를 하면 그 권한을 스레드들은 다 공유하게 된다. 그리고 가상메모리라는 공간은 여러 프로세스가 실행되고 있어도 이 가상 메모리 공간은 독립적인 공간으로서 보장을 받는다. 그리고 그 스레드들이 가상 메모리를 사용이 가능하다. 우리가 OS내에서 새로운 프로세스를 생성해야 한다고 보면 새로운 프로세스가 생성이 될 때마다 독립적인 가상메모리 공간을 가져야 하는데 가상메모리 공간을 프로세스마다 OS가 할당해줘야 한다.

만약 어떤 프로세스가 있다고 해보자. 이 프로세스는 자기만의 고유의 PCB도 갖고 가상메모리 공간을 갖는다. 이 프로세스가 새로운 프로세스를 생성을 하면 이 2개의 프로세스의 관계가 설정이 되는데 기존 프로세스를 부모 프로세스, 새로 생긴 프로세스를 자식 프로세스라고 한다. 그런데 신기한 것이 위의 표를 보면 윈도우 경우 프로세스 생성 함수가 createProcess로 하나지만 UNIX는 fork(), exec() 2개가 존재한다. 왜 그런 것일까?

프로세스가 생성이 되면 이 프로세스를 쓰기 위해서 메모리(text영역에 존재하는 실행코드)로 복사 후 이 실행코드에 대한 PCB가 생성이 되고, 가상메모리 공간이 확보가 된다. 이 가상메모리 공간 속에 heap영역, Stack영역, Data라는 정적 static 영역등이 들어가져 있다. 즉, 우리가 느끼기에 프로세스 생성 과정이 엄청 복잡하게 느껴진다. 그렇게 못 느끼신 분들을 위해 좀 더 설명해 보겠다. 우리가 C/C++을 배워서 실행파일을 만들면 Unix계열은 a.out으로 Window는 a.exe로 떨어진다. 이때, 윈도우 계열 실행파일은 PE format을 하고 있고 유닉스 계열은 ELF format을 하고 있다. 이때, PE format과 ELF format은 서로 비슷하지만 PE format이 좀 더 복잡하다. 아래 그림을 보면 이해될 것이다.

즉, 프로세스가 생성이 되면 메모리에 복사가 되고 거기서 PE형식을 뜯어서 분해한 다음에 거기서 text section이라는데 가서 코드를 뜯어서 올리는데 그전에 PCB 생성이 되고 가상 메모리 공간 할당을 한다. 이 과정이 굉장히 복잡하고 오래 걸려서 이 작업을 효율적으로 하다 보니 Window에서는 createProcess() 하나지만 Linux에서는 fork(), exec() 2개로 구성이 된다. 그럼 본론으로 가서 왜 2개일까?

이 복잡한 과정을 효율적으로 처리하기 위해서이긴 한데, fork()는 프로그램이 실행되고 프로세스가 생성하고 가상메모리공간 + PCB 생성 + OS처리를 하는 이 과정을 자식 프로세스에게 그대로 복사해서 레지스터 상태정보, 실행코드만 리셋시켜 주는 형태인데 이때 만일 부모 프로세스가 종료된다고 하면 너무 비효율적인 작업만 하고 종료되는 게 안타까울 것이다. 이에 반해 exec()는 자식 프로세스를 만들 필요 없이 종료될 프로세스에 레지스터 상태정보, 코드만 종료될 프로세스에 넣어주는 형태이다. 이렇게 보면 exec()가 좀 더 효율적이다. 그래서 되도록 exec()를 사용하는 것이 좋다. 좀 더 쉽게 얘기해보면 다음과 같다.

fork() 시스템 호출은 새로운 프로세스를 위한 메모리를 할당한다는 것이다. 그리고 fork()를 호출한 프로세스를 새로운 공간으로 전부 복사하게 되고, 원래 프로세스는 원래 프로세스대로 작업을 실행하고 fork()를 이용해서 생성된 프로세스도 그 나름대로 fork() 시스템 콜이 수행된 라인의 다음 라인부터 실행이 된다. (새로 생성된 프로세스는 원래의 프로세스와 똑같은 코드를 가지고 있다.) 반면, exec()는 fork()처럼 새로운 프로세스를 위한 메모리를 할당하지 않고, exec()를 호출한 프로세스가 아닌 exec()에 의해 호출된 프로세스만 메모리에 남게 된다.

간단히 정리하면, fork()의 결과는 프로세스가 하나 더 생기는 것이다.( = 프로세스 id- PID 가 완전히 다른 또 하나의 프로세스가 생기는 것). 반면 exec() 실행의 결과로 생성되는 새로운 프로세스는 없고, exec()를 호출한 프로세스의 PID가 그대로 새로운 프로세스에 적용이 되며, exec()를 호출한 프로세스는 새로운 프로세스에 의해 덮어 쓰이게 된다.

그리고 wait와 waitForSingleObject는 어떤 하나의 Object를 기다린다는 말로 가끔 프로세스가 종료될 때까지 기다려야 하는 상황에 사용한다. 이 함수들을 사용하면 프로세스 상태가 대기상태로 빠지게 된다.

> 이 포스트는 [널널한 개발자](https://www.inflearn.com/course/%EA%B3%B0%EC%B1%85-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)님의 강의를 듣고 작성한 글입니다.

## 멀티스레딩과 동기화 기본

프로세스가 여러 개 있는 경우를 멀티 태스킹이라 한다. 프로세스에게 OS가 권한도 부여하고 VMS를 프로세스 단위로 부여한다. 이런 VMS를 공유한다는 것이 스레드의 특징이다.

> VMS는 공간적인 의미로 스레드 각자 차지하는 공간이 Stack, 나머지 공용공간을 heap이라고 한다. 추가적으로 Data 영역이 있는데 이 공간에는 전역변수 같은 것들이 들어가져 있다.

무언가 여러개가 되면 동기화 이슈가 난다. 예를 들어 VMS가 집이라고 가정하면 가장 동기화 이슈가 많이 일어나는 것이 화장실이다. 스레드들이 화장실이라는 자원을 먼저 선점하려고 노력을 할 것이다. 특히 아침시간대에 일어나는데 아침시간대를 병목현상이 일어날 때 발생할 것이다. 혹은 race condition(경쟁 상태)가 발생한다. 이런 race condition은 냉장고 같은데서 맛있는 걸 먼저 먹으려고 할 때 일어난다. 즉, 이런 상황으로 설계할 것이냐 아니면 조그마한 오피스텔처럼 각각의 방에 부엌, 화장실, 침실이 있는 경우로 설계할 것이냐인데 전자의 경우가 멀티스레드 환경, 후자의 경우가 멀티태스킹 환경이라고 한다. 보통의 경우 후자가 더 효율적이라고 느낄 수 있지만 굳이 여러 개의 부엌, 화장실이 있으면 자원의 낭비가 될 수 있어 멀티태스킹 환경보다는 멀티스레드 환경이 더 효율적인 측면에서 유리하다고 볼 수 있다.

스레드는 연산의 단위인데 CPU라는 자원을 선점하는 것은 프로세스가 아니라 스레드가 선점한다. 다만, CPU가 코어 8개라고 하면 코어 8개중 몇 개를 쓰라고 OS가 권한을 부여하는데 이는 프로세스한테 부여한다. 그래서 스레드는 프로세스에 대한 권한이라던가 리소스 할당같은 경우 제한을 받는다. 그래서 VMS에서 공통요소로 볼 수 있는 정적영역은 같이 쓰고 개별화된 스택은 스레드마다 가져간다. 스택에는 지역변수 + 자동변수에 쓰는데 용량이 굉장히 적다. 그리고 레지스터 정보에는 TCB가 있는데 스레드마다 실행이 이루어지고 연산을 하고 CPU의 코어가 하다보니 이 코어 속에 그때의 레지스터가 들어가져 있다. 그래서 뭔가 연산을 하게 되면 이 CPU의 코어의 레지스터의 변화가 생긴다. 그 코어의 레지스터 상태를 백업했다가 되돌렸다가 하는데 그걸 Context Switching이라고 한다.

> 스레드는 프로세스처럼 상태를 가진다. 그래서 프로세스가 어떤 상태를 가진다는 것은 그 안의 스레드가 그 상태를 가진다고 볼 수 있다.

그러면 스레드는 왜 사용할까? 기본적으로 프로그램이 실행이 되면 보통 우리는 GUI를 보고 프로그램이 죽었는지 살았는지 알 수 있다. 근데 표면적인 것 외에 내부처리가 있을 수 있는데 즉, GUI와 내부처리는 별도의 스레드를 사용한다. 즉 개별화된 흐름이 이루어지는데 이 둘 간의 동기화가 가장 중요한 이슈다.

그러면 동기화 문제와 동기화하는 코드를 보겠다.

``` c++
#include <iostream>
#include <Windows.h>
#include <process.h>

int g_data;

bool g_bFlag = true;

void threadFunction01(void* pArgs) {
  std::cout << "threadFunction01 - Begin\n";

  while (g_bFlag) {
    g_data = 1000;
  }
  
  std::cout << "threadFunction01 - End\n";
}

void threadFunction02(void* pArgs) {
  std::cout << "threadFunction02 - Begin\n";

  while (g_bFlag) {
    g_data = 2000;
  }

  std::cout << "threadFunction02 - End\n";
}

void threadFunction03(void* pArgs) {
  for (int i = 0; i < 10; ++i) {
    std::cout << "threadFunction03() g_data: " << g_data << std::endl;
    Sleep(0);
  }
}

int main() {
  std::cout << "Hello World! - Begin\n";

  g_bFlag = true;

  ::_beginthread(threadFunction01, 0, nullptr);
  ::_beginthread(threadFunction02, 0, nullptr);
  ::_beginthread(threadFunction03, 0, nullptr);

  // 호출자 쓰레드가 대기상태로 전환
  ::Sleep(100); // 우연에 맡기는 코드

  g_bFlag = false;

  std::cout << "Hello World! - End\n";
}
```

위의 코드를 보면 c++로 스레드간 race-condition을 발생한 상태이다. 매인 함수 안에 각각의 스레드 함수를 실행시켰다. 그리고 호출자 스레드를 대기상태로 전환을 하면 어떻게 될까? 어느 스레드가 먼저 호출될까? 그건 모른다. 심지어 메인 스레드가 종료가 되고나서 스레드 1번이 종료될 수 있고 나머지 스레드들은 종료가 안 될 수 있다.

그럼 이 부분을 어떻게 동기화(교통정리)를 해줄까?

``` c++
#include <iostream>
#include <Windows.h>
#include <process.h>

int g_data;
bool g_bFlag = true;
HANDLE g_hThreadExit01, g_hThreadExit02, g_hThreadExit03;

void threadFunction01(void* pArgs) {
  std::cout << "threadFunction01 - Begin\n";

  while (g_bFlag) {
    g_data = 1000;
  }
  
  std::cout << "threadFunction01 - End\n";
  ::SetEvent(g_hThreadExit01);
}

void threadFunction02(void* pArgs) {
  std::cout << "threadFunction02 - Begin\n";

  while (g_bFlag) {
    g_data = 2000;
  }

  std::cout << "threadFunction02 - End\n";
  ::SetEvent(g_hThreadExit02);
}

void threadFunction03(void* pArgs) {
  for (int i = 0; i < 10; ++i) {
    std::cout << "threadFunction03() g_data: " << g_data << std::endl;
    Sleep(0);
  }

  ::SetEvent(g_hThreadExit03);
}

int main() {
  std::cout << "Hello World! - Begin\n";

  g_bFlag = true;

  g_hThreadExit01 = ::CreateEventA(nullptr, true, false, "T_THREAD_01");
  g_hThreadExit02 = ::CreateEventA(nullptr, true, false, "T_THREAD_02");
  g_hThreadExit03 = ::CreateEventA(nullptr, true, false, "T_THREAD_03");

  ::_beginthread(threadFunction01, 0, nullptr);
  ::_beginthread(threadFunction02, 0, nullptr);

  ::Sleep(10);

  ::_beginthread(threadFunction03, 0, nullptr);

  // 호출자 쓰레드가 대기상태로 전환
  // ::Sleep(100); // 우연에 맡기는 코드

  ::WaitForSingleObject(g_hThreadExit03, INFINITE);

  g_bFlag = false;

  // T1, T2의 종료 이벤트를 대기
  ::WaitForSingleObject(g_hThreadExit01, INFINITE);
  ::WaitForSingleObject(g_hThreadExit02, INFINITE);

  ::CloseHandle(g_hThreadExit01);
  ::CloseHandle(g_hThreadExit02);
  ::CloseHandle(g_hThreadExit03);

  std::cout << "Hello World! - End\n";
}
```

C++의 void pointer인 HANDLE을 사용하여 전역변수를 설정하고 CreateEventA라는 메서드로 동기화 작업을 해준다. 그리고 종료 전에 종료 이벤트를 대기시켜 주는 형식으로 동기화를 한다. 저자는 C++의 문법에 익숙치 않지만 여기서 핵심은 스레드 간의 전역변수라는 자원을 변경하려는 시도를 동시에 진행을 한다. 동기화를 해주지 않으면 예상치 못한 결과를 얻을 것이므로 스레드 프로그래밍을 할 경우 이런 동기화 작업을 적절히 생각을 하고 Sleep() 함수등을 적절히 사용해야 한다.